// Code generated by Prisma Client Rust. DO NOT EDIT

pub static DATAMODEL_STR: &'static str =
    include_str!("D:\\development\\stargazer\\prisma\\schema.prisma");
static DATABASE_STR: &'static str = "sqlite";
pub async fn new_client() -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    PrismaClient::_builder().build().await
}
pub async fn new_client_with_url(
    url: &str,
) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    PrismaClient::_builder()
        .with_url(url.to_string())
        .build()
        .await
}
pub mod player {
    use super::*;
    pub const NAME: &str = "Player";
    pub mod id {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
        };
        pub const NAME: &str = "Id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Id, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod numeric_id {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "NumericId";
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetNumericId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::NumericId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::NumericId(direction)
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::NumericId(_prisma::read_filters::BigIntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BigIntFilter,
            NumericId,
            {
                fn in_vec(_: Vec<i64>) -> InVec;
                fn not_in_vec(_: Vec<i64>) -> NotInVec;
                fn lt(_: i64) -> Lt;
                fn lte(_: i64) -> Lte;
                fn gt(_: i64) -> Gt;
                fn gte(_: i64) -> Gte;
                fn not(_: i64) -> Not;
            }
        );
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementNumericId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementNumericId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyNumericId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideNumericId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::NumericId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::NumericId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod handle {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "Handle";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetHandle(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Handle(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Handle(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Handle(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Handle,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Handle(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Handle(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod email {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "Email";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetEmail(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Email(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Email(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Email(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Email,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Email(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Email(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod hashed_password {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "HashedPassword";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetHashedPassword(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::HashedPassword(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::HashedPassword(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::HashedPassword(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            HashedPassword,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::HashedPassword(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::HashedPassword(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod hashed_temporary_password {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "HashedTemporaryPassword";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetHashedTemporaryPassword(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::HashedTemporaryPassword(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::HashedTemporaryPassword(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::HashedTemporaryPassword(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            HashedTemporaryPassword,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::HashedTemporaryPassword(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::HashedTemporaryPassword(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod total_play_time {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "TotalPlayTime";
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTotalPlayTime(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::TotalPlayTime(v)
            }
        }
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::TotalPlayTime(direction)
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::TotalPlayTime(_prisma::read_filters::BigIntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BigIntFilter,
            TotalPlayTime,
            {
                fn in_vec(_: Vec<i64>) -> InVec;
                fn not_in_vec(_: Vec<i64>) -> NotInVec;
                fn lt(_: i64) -> Lt;
                fn lte(_: i64) -> Lte;
                fn gt(_: i64) -> Gt;
                fn gte(_: i64) -> Gte;
                fn not(_: i64) -> Not;
            }
        );
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementTotalPlayTime(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementTotalPlayTime(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyTotalPlayTime(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideTotalPlayTime(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::TotalPlayTime(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::TotalPlayTime(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod level {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "Level";
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetLevel(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Level(v)
            }
        }
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Level(direction)
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::Level(_prisma::read_filters::BigIntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BigIntFilter,
            Level,
            {
                fn in_vec(_: Vec<i64>) -> InVec;
                fn not_in_vec(_: Vec<i64>) -> NotInVec;
                fn lt(_: i64) -> Lt;
                fn lte(_: i64) -> Lte;
                fn gt(_: i64) -> Gt;
                fn gte(_: i64) -> Gte;
                fn not(_: i64) -> Not;
            }
        );
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementLevel(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementLevel(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyLevel(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideLevel(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Level(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Level(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod exp_of_level {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "ExpOfLevel";
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetExpOfLevel(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ExpOfLevel(v)
            }
        }
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ExpOfLevel(direction)
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::ExpOfLevel(_prisma::read_filters::BigIntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BigIntFilter,
            ExpOfLevel,
            {
                fn in_vec(_: Vec<i64>) -> InVec;
                fn not_in_vec(_: Vec<i64>) -> NotInVec;
                fn lt(_: i64) -> Lt;
                fn lte(_: i64) -> Lte;
                fn gt(_: i64) -> Gt;
                fn gte(_: i64) -> Gte;
                fn not(_: i64) -> Not;
            }
        );
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementExpOfLevel(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementExpOfLevel(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyExpOfLevel(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideExpOfLevel(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ExpOfLevel(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ExpOfLevel(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod creation_date {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "CreationDate";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCreationDate(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CreationDate(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreationDate(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreationDate(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            CreationDate,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreationDate(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreationDate(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod achievements {
        use super::super::*;
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "Achievements";
        pub struct Fetch(pub achievement::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<achievement::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: achievement::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: achievement::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Achievements(v)
            }
        }
        pub fn fetch(params: Vec<achievement::WhereParam>) -> Fetch {
            Fetch(achievement::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<achievement::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectAchievements(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<achievement::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<achievement::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectAchievements(params)
        }
        pub fn set(params: Vec<achievement::UniqueWhereParam>) -> SetParam {
            SetParam::SetAchievements(params)
        }
        pub fn some(value: Vec<achievement::WhereParam>) -> WhereParam {
            WhereParam::AchievementsSome(value)
        }
        pub fn every(value: Vec<achievement::WhereParam>) -> WhereParam {
            WhereParam::AchievementsEvery(value)
        }
        pub fn none(value: Vec<achievement::WhereParam>) -> WhereParam {
            WhereParam::AchievementsNone(value)
        }
        pub enum Include {
            Select(achievement::ManyArgs, Vec<achievement::SelectParam>),
            Include(achievement::ManyArgs, Vec<achievement::IncludeParam>),
            Fetch(achievement::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Achievements(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = <achievement::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <achievement::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: achievement::ManyArgs,
                nested_selections: Vec<achievement::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: achievement::ManyArgs,
                nested_selections: Vec<achievement::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(achievement::ManyArgs, Vec<achievement::SelectParam>),
            Include(achievement::ManyArgs, Vec<achievement::IncludeParam>),
            Fetch(achievement::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Achievements(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <achievement::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: achievement::ManyArgs,
                nested_selections: Vec<achievement::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: achievement::ManyArgs,
                nested_selections: Vec<achievement::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod friends_of {
        use super::super::*;
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "FriendsOf";
        pub struct Fetch(pub player::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<player::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: player::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: player::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::FriendsOf(v)
            }
        }
        pub fn fetch(params: Vec<player::WhereParam>) -> Fetch {
            Fetch(player::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<player::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectFriendsOf(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<player::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<player::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectFriendsOf(params)
        }
        pub fn set(params: Vec<player::UniqueWhereParam>) -> SetParam {
            SetParam::SetFriendsOf(params)
        }
        pub fn some(value: Vec<player::WhereParam>) -> WhereParam {
            WhereParam::FriendsOfSome(value)
        }
        pub fn every(value: Vec<player::WhereParam>) -> WhereParam {
            WhereParam::FriendsOfEvery(value)
        }
        pub fn none(value: Vec<player::WhereParam>) -> WhereParam {
            WhereParam::FriendsOfNone(value)
        }
        pub enum Include {
            Select(player::ManyArgs, Vec<player::SelectParam>),
            Include(player::ManyArgs, Vec<player::IncludeParam>),
            Fetch(player::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::FriendsOf(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections =
                            <player::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <player::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: player::ManyArgs,
                nested_selections: Vec<player::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: player::ManyArgs,
                nested_selections: Vec<player::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(player::ManyArgs, Vec<player::SelectParam>),
            Include(player::ManyArgs, Vec<player::IncludeParam>),
            Fetch(player::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::FriendsOf(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <player::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: player::ManyArgs,
                nested_selections: Vec<player::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: player::ManyArgs,
                nested_selections: Vec<player::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod friends_with {
        use super::super::*;
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "FriendsWith";
        pub struct Fetch(pub player::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<player::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: player::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: player::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::FriendsWith(v)
            }
        }
        pub fn fetch(params: Vec<player::WhereParam>) -> Fetch {
            Fetch(player::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<player::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectFriendsWith(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<player::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<player::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectFriendsWith(params)
        }
        pub fn set(params: Vec<player::UniqueWhereParam>) -> SetParam {
            SetParam::SetFriendsWith(params)
        }
        pub fn some(value: Vec<player::WhereParam>) -> WhereParam {
            WhereParam::FriendsWithSome(value)
        }
        pub fn every(value: Vec<player::WhereParam>) -> WhereParam {
            WhereParam::FriendsWithEvery(value)
        }
        pub fn none(value: Vec<player::WhereParam>) -> WhereParam {
            WhereParam::FriendsWithNone(value)
        }
        pub enum Include {
            Select(player::ManyArgs, Vec<player::SelectParam>),
            Include(player::ManyArgs, Vec<player::IncludeParam>),
            Fetch(player::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::FriendsWith(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections =
                            <player::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <player::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: player::ManyArgs,
                nested_selections: Vec<player::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: player::ManyArgs,
                nested_selections: Vec<player::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(player::ManyArgs, Vec<player::SelectParam>),
            Include(player::ManyArgs, Vec<player::IncludeParam>),
            Fetch(player::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::FriendsWith(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <player::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: player::ManyArgs,
                nested_selections: Vec<player::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: player::ManyArgs,
                nested_selections: Vec<player::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod scores {
        use super::super::*;
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "Scores";
        pub struct Fetch(pub score::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<score::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: score::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: score::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Scores(v)
            }
        }
        pub fn fetch(params: Vec<score::WhereParam>) -> Fetch {
            Fetch(score::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<score::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectScores(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<score::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<score::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectScores(params)
        }
        pub fn set(params: Vec<score::UniqueWhereParam>) -> SetParam {
            SetParam::SetScores(params)
        }
        pub fn some(value: Vec<score::WhereParam>) -> WhereParam {
            WhereParam::ScoresSome(value)
        }
        pub fn every(value: Vec<score::WhereParam>) -> WhereParam {
            WhereParam::ScoresEvery(value)
        }
        pub fn none(value: Vec<score::WhereParam>) -> WhereParam {
            WhereParam::ScoresNone(value)
        }
        pub enum Include {
            Select(score::ManyArgs, Vec<score::SelectParam>),
            Include(score::ManyArgs, Vec<score::IncludeParam>),
            Fetch(score::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Scores(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections =
                            <score::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <score::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: score::ManyArgs,
                nested_selections: Vec<score::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: score::ManyArgs,
                nested_selections: Vec<score::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(score::ManyArgs, Vec<score::SelectParam>),
            Include(score::ManyArgs, Vec<score::IncludeParam>),
            Fetch(score::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Scores(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <score::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: score::ManyArgs,
                nested_selections: Vec<score::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: score::ManyArgs,
                nested_selections: Vec<score::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod setting {
        use super::super::*;
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "Setting";
        pub struct Fetch(pub setting::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<setting::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Setting(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(setting::UniqueArgs::new())
        }
        pub struct Connect(setting::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectSetting(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: setting::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectSetting
        }
        pub fn is_null() -> WhereParam {
            WhereParam::SettingIsNull
        }
        pub fn is(value: Vec<setting::WhereParam>) -> WhereParam {
            WhereParam::SettingIs(value)
        }
        pub fn is_not(value: Vec<setting::WhereParam>) -> WhereParam {
            WhereParam::SettingIsNot(value)
        }
        pub enum Include {
            Select(Vec<setting::SelectParam>),
            Include(Vec<setting::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Setting(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <setting::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <setting::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("Setting", None, [], selections)
            }
            pub fn select(nested_selections: Vec<setting::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<setting::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<setting::SelectParam>),
            Include(Vec<setting::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Setting(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <setting::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("Setting", None, [], selections)
            }
            pub fn select(nested_selections: Vec<setting::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<setting::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(
        numeric_id: i64,
        handle: String,
        email: String,
        hashed_password: String,
        hashed_temporary_password: String,
        total_play_time: i64,
        level: i64,
        exp_of_level: i64,
        _params: Vec<SetParam>,
    ) -> (
        i64,
        String,
        String,
        String,
        String,
        i64,
        i64,
        i64,
        Vec<SetParam>,
    ) {
        (
            numeric_id,
            handle,
            email,
            hashed_password,
            hashed_temporary_password,
            total_play_time,
            level,
            exp_of_level,
            _params,
        )
    }
    pub fn create_unchecked(
        numeric_id: i64,
        handle: String,
        email: String,
        hashed_password: String,
        hashed_temporary_password: String,
        total_play_time: i64,
        level: i64,
        exp_of_level: i64,
        _params: Vec<SetParam>,
    ) -> (
        i64,
        String,
        String,
        String,
        String,
        i64,
        i64,
        i64,
        Vec<SetParam>,
    ) {
        (
            numeric_id,
            handle,
            email,
            hashed_password,
            hashed_temporary_password,
            total_play_time,
            level,
            exp_of_level,
            _params,
        )
    }
    #[macro_export]
    macro_rules! _select_player { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: player :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: player :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: player :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: player :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: player :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: player :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , numeric_id , handle , email , hashed_password , hashed_temporary_password , total_play_time , level , exp_of_level , creation_date , achievements , friends_of , friends_with , scores , setting } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: player :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: player :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: player :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: player :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: player :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: player :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["Id" , "NumericId" , "Handle" , "Email" , "HashedPassword" , "HashedTemporaryPassword" , "TotalPlayTime" , "Level" , "ExpOfLevel" , "CreationDate" , "Achievements" , "FriendsOf" , "FriendsWith" , "Scores" , "Setting"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: player :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; numeric_id) => { i64 } ; (@ field_type ; handle) => { String } ; (@ field_type ; email) => { String } ; (@ field_type ; hashed_password) => { String } ; (@ field_type ; hashed_temporary_password) => { String } ; (@ field_type ; total_play_time) => { i64 } ; (@ field_type ; level) => { i64 } ; (@ field_type ; exp_of_level) => { i64 } ; (@ field_type ; creation_date) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; achievements : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < achievements :: Data > } ; (@ field_type ; achievements) => { Vec < crate :: prisma :: achievement :: Data > } ; (@ field_type ; friends_of : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < friends_of :: Data > } ; (@ field_type ; friends_of) => { Vec < crate :: prisma :: player :: Data > } ; (@ field_type ; friends_with : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < friends_with :: Data > } ; (@ field_type ; friends_with) => { Vec < crate :: prisma :: player :: Data > } ; (@ field_type ; scores : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < scores :: Data > } ; (@ field_type ; scores) => { Vec < crate :: prisma :: score :: Data > } ; (@ field_type ; setting : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < setting :: Data > } ; (@ field_type ; setting) => { Option < crate :: prisma :: setting :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Player" , available relations are "id, numeric_id, handle, email, hashed_password, hashed_temporary_password, total_play_time, level, exp_of_level, creation_date, achievements, friends_of, friends_with, scores, setting")) } ; (@ field_module ; achievements : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: achievement :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; friends_of : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: player :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; friends_with : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: player :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; scores : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: score :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; setting : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: setting :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: player :: SelectParam > :: into (crate :: prisma :: player :: id :: Select) } ; (@ selection_field_to_selection_param ; numeric_id) => { Into :: < crate :: prisma :: player :: SelectParam > :: into (crate :: prisma :: player :: numeric_id :: Select) } ; (@ selection_field_to_selection_param ; handle) => { Into :: < crate :: prisma :: player :: SelectParam > :: into (crate :: prisma :: player :: handle :: Select) } ; (@ selection_field_to_selection_param ; email) => { Into :: < crate :: prisma :: player :: SelectParam > :: into (crate :: prisma :: player :: email :: Select) } ; (@ selection_field_to_selection_param ; hashed_password) => { Into :: < crate :: prisma :: player :: SelectParam > :: into (crate :: prisma :: player :: hashed_password :: Select) } ; (@ selection_field_to_selection_param ; hashed_temporary_password) => { Into :: < crate :: prisma :: player :: SelectParam > :: into (crate :: prisma :: player :: hashed_temporary_password :: Select) } ; (@ selection_field_to_selection_param ; total_play_time) => { Into :: < crate :: prisma :: player :: SelectParam > :: into (crate :: prisma :: player :: total_play_time :: Select) } ; (@ selection_field_to_selection_param ; level) => { Into :: < crate :: prisma :: player :: SelectParam > :: into (crate :: prisma :: player :: level :: Select) } ; (@ selection_field_to_selection_param ; exp_of_level) => { Into :: < crate :: prisma :: player :: SelectParam > :: into (crate :: prisma :: player :: exp_of_level :: Select) } ; (@ selection_field_to_selection_param ; creation_date) => { Into :: < crate :: prisma :: player :: SelectParam > :: into (crate :: prisma :: player :: creation_date :: Select) } ; (@ selection_field_to_selection_param ; achievements $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: player :: SelectParam > :: into (crate :: prisma :: player :: achievements :: Select :: $ selection_mode (crate :: prisma :: achievement :: ManyArgs :: new (crate :: prisma :: achievement :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: achievement :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; achievements $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: player :: SelectParam > :: into (crate :: prisma :: player :: achievements :: Select :: Fetch (crate :: prisma :: achievement :: ManyArgs :: new (crate :: prisma :: achievement :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; friends_of $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: player :: SelectParam > :: into (crate :: prisma :: player :: friends_of :: Select :: $ selection_mode (crate :: prisma :: player :: ManyArgs :: new (crate :: prisma :: player :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: player :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; friends_of $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: player :: SelectParam > :: into (crate :: prisma :: player :: friends_of :: Select :: Fetch (crate :: prisma :: player :: ManyArgs :: new (crate :: prisma :: player :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; friends_with $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: player :: SelectParam > :: into (crate :: prisma :: player :: friends_with :: Select :: $ selection_mode (crate :: prisma :: player :: ManyArgs :: new (crate :: prisma :: player :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: player :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; friends_with $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: player :: SelectParam > :: into (crate :: prisma :: player :: friends_with :: Select :: Fetch (crate :: prisma :: player :: ManyArgs :: new (crate :: prisma :: player :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; scores $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: player :: SelectParam > :: into (crate :: prisma :: player :: scores :: Select :: $ selection_mode (crate :: prisma :: score :: ManyArgs :: new (crate :: prisma :: score :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: score :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; scores $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: player :: SelectParam > :: into (crate :: prisma :: player :: scores :: Select :: Fetch (crate :: prisma :: score :: ManyArgs :: new (crate :: prisma :: score :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; setting $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: player :: SelectParam > :: into (crate :: prisma :: player :: setting :: Select :: $ selection_mode (crate :: prisma :: setting :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; setting $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: player :: SelectParam > :: into (crate :: prisma :: player :: setting :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: player :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "Id" } ; (@ field_serde_name ; numeric_id) => { "NumericId" } ; (@ field_serde_name ; handle) => { "Handle" } ; (@ field_serde_name ; email) => { "Email" } ; (@ field_serde_name ; hashed_password) => { "HashedPassword" } ; (@ field_serde_name ; hashed_temporary_password) => { "HashedTemporaryPassword" } ; (@ field_serde_name ; total_play_time) => { "TotalPlayTime" } ; (@ field_serde_name ; level) => { "Level" } ; (@ field_serde_name ; exp_of_level) => { "ExpOfLevel" } ; (@ field_serde_name ; creation_date) => { "CreationDate" } ; (@ field_serde_name ; achievements) => { "Achievements" } ; (@ field_serde_name ; friends_of) => { "FriendsOf" } ; (@ field_serde_name ; friends_with) => { "FriendsWith" } ; (@ field_serde_name ; scores) => { "Scores" } ; (@ field_serde_name ; setting) => { "Setting" } ; }
    pub use _select_player as select;
    pub enum SelectParam {
        Id(id::Select),
        NumericId(numeric_id::Select),
        Handle(handle::Select),
        Email(email::Select),
        HashedPassword(hashed_password::Select),
        HashedTemporaryPassword(hashed_temporary_password::Select),
        TotalPlayTime(total_play_time::Select),
        Level(level::Select),
        ExpOfLevel(exp_of_level::Select),
        CreationDate(creation_date::Select),
        Achievements(achievements::Select),
        FriendsOf(friends_of::Select),
        FriendsWith(friends_with::Select),
        Scores(scores::Select),
        Setting(setting::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::NumericId(data) => data.to_selection(),
                Self::Handle(data) => data.to_selection(),
                Self::Email(data) => data.to_selection(),
                Self::HashedPassword(data) => data.to_selection(),
                Self::HashedTemporaryPassword(data) => data.to_selection(),
                Self::TotalPlayTime(data) => data.to_selection(),
                Self::Level(data) => data.to_selection(),
                Self::ExpOfLevel(data) => data.to_selection(),
                Self::CreationDate(data) => data.to_selection(),
                Self::Achievements(data) => data.to_selection(),
                Self::FriendsOf(data) => data.to_selection(),
                Self::FriendsWith(data) => data.to_selection(),
                Self::Scores(data) => data.to_selection(),
                Self::Setting(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules! _include_player { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: player :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: player :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: player :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: player :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: player :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: player :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: player :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: player :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { achievements , friends_of , friends_with , scores , setting } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub numeric_id : i64 , pub handle : String , pub email : String , pub hashed_password : String , pub hashed_temporary_password : String , pub total_play_time : i64 , pub level : i64 , pub exp_of_level : i64 , pub creation_date : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (pub $ field : crate :: prisma :: player :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (numeric_id) , stringify ! (handle) , stringify ! (email) , stringify ! (hashed_password) , stringify ! (hashed_temporary_password) , stringify ! (total_play_time) , stringify ! (level) , stringify ! (exp_of_level) , stringify ! (creation_date)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: player :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: player :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: player :: numeric_id :: NAME , & self . numeric_id) ? ; state . serialize_field (crate :: prisma :: player :: handle :: NAME , & self . handle) ? ; state . serialize_field (crate :: prisma :: player :: email :: NAME , & self . email) ? ; state . serialize_field (crate :: prisma :: player :: hashed_password :: NAME , & self . hashed_password) ? ; state . serialize_field (crate :: prisma :: player :: hashed_temporary_password :: NAME , & self . hashed_temporary_password) ? ; state . serialize_field (crate :: prisma :: player :: total_play_time :: NAME , & self . total_play_time) ? ; state . serialize_field (crate :: prisma :: player :: level :: NAME , & self . level) ? ; state . serialize_field (crate :: prisma :: player :: exp_of_level :: NAME , & self . exp_of_level) ? ; state . serialize_field (crate :: prisma :: player :: creation_date :: NAME , & self . creation_date) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , numeric_id , handle , email , hashed_password , hashed_temporary_password , total_play_time , level , exp_of_level , creation_date } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: player :: $ field :: NAME) , + , crate :: prisma :: player :: id :: NAME , crate :: prisma :: player :: numeric_id :: NAME , crate :: prisma :: player :: handle :: NAME , crate :: prisma :: player :: email :: NAME , crate :: prisma :: player :: hashed_password :: NAME , crate :: prisma :: player :: hashed_temporary_password :: NAME , crate :: prisma :: player :: total_play_time :: NAME , crate :: prisma :: player :: level :: NAME , crate :: prisma :: player :: exp_of_level :: NAME , crate :: prisma :: player :: creation_date :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: player :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: player :: id :: NAME => Ok (Field :: id) , crate :: prisma :: player :: numeric_id :: NAME => Ok (Field :: numeric_id) , crate :: prisma :: player :: handle :: NAME => Ok (Field :: handle) , crate :: prisma :: player :: email :: NAME => Ok (Field :: email) , crate :: prisma :: player :: hashed_password :: NAME => Ok (Field :: hashed_password) , crate :: prisma :: player :: hashed_temporary_password :: NAME => Ok (Field :: hashed_temporary_password) , crate :: prisma :: player :: total_play_time :: NAME => Ok (Field :: total_play_time) , crate :: prisma :: player :: level :: NAME => Ok (Field :: level) , crate :: prisma :: player :: exp_of_level :: NAME => Ok (Field :: exp_of_level) , crate :: prisma :: player :: creation_date :: NAME => Ok (Field :: creation_date) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut numeric_id = None ; let mut handle = None ; let mut email = None ; let mut hashed_password = None ; let mut hashed_temporary_password = None ; let mut total_play_time = None ; let mut level = None ; let mut exp_of_level = None ; let mut creation_date = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: player :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: numeric_id => { if numeric_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: player :: numeric_id :: NAME)) ; } numeric_id = Some (map . next_value () ?) ; } Field :: handle => { if handle . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: player :: handle :: NAME)) ; } handle = Some (map . next_value () ?) ; } Field :: email => { if email . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: player :: email :: NAME)) ; } email = Some (map . next_value () ?) ; } Field :: hashed_password => { if hashed_password . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: player :: hashed_password :: NAME)) ; } hashed_password = Some (map . next_value () ?) ; } Field :: hashed_temporary_password => { if hashed_temporary_password . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: player :: hashed_temporary_password :: NAME)) ; } hashed_temporary_password = Some (map . next_value () ?) ; } Field :: total_play_time => { if total_play_time . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: player :: total_play_time :: NAME)) ; } total_play_time = Some (map . next_value () ?) ; } Field :: level => { if level . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: player :: level :: NAME)) ; } level = Some (map . next_value () ?) ; } Field :: exp_of_level => { if exp_of_level . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: player :: exp_of_level :: NAME)) ; } exp_of_level = Some (map . next_value () ?) ; } Field :: creation_date => { if creation_date . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: player :: creation_date :: NAME)) ; } creation_date = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: player :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: player :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: player :: id :: NAME)) ? ; let numeric_id = numeric_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: player :: numeric_id :: NAME)) ? ; let handle = handle . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: player :: handle :: NAME)) ? ; let email = email . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: player :: email :: NAME)) ? ; let hashed_password = hashed_password . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: player :: hashed_password :: NAME)) ? ; let hashed_temporary_password = hashed_temporary_password . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: player :: hashed_temporary_password :: NAME)) ? ; let total_play_time = total_play_time . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: player :: total_play_time :: NAME)) ? ; let level = level . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: player :: level :: NAME)) ? ; let exp_of_level = exp_of_level . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: player :: exp_of_level :: NAME)) ? ; let creation_date = creation_date . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: player :: creation_date :: NAME)) ? ; Ok (Data { id , numeric_id , handle , email , hashed_password , hashed_temporary_password , total_play_time , level , exp_of_level , creation_date , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["Id" , "NumericId" , "Handle" , "Email" , "HashedPassword" , "HashedTemporaryPassword" , "TotalPlayTime" , "Level" , "ExpOfLevel" , "CreationDate" , "Achievements" , "FriendsOf" , "FriendsWith" , "Scores" , "Setting"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: player :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; achievements : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < achievements :: Data > } ; (@ field_type ; achievements) => { Vec < crate :: prisma :: achievement :: Data > } ; (@ field_type ; friends_of : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < friends_of :: Data > } ; (@ field_type ; friends_of) => { Vec < crate :: prisma :: player :: Data > } ; (@ field_type ; friends_with : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < friends_with :: Data > } ; (@ field_type ; friends_with) => { Vec < crate :: prisma :: player :: Data > } ; (@ field_type ; scores : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < scores :: Data > } ; (@ field_type ; scores) => { Vec < crate :: prisma :: score :: Data > } ; (@ field_type ; setting : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < setting :: Data > } ; (@ field_type ; setting) => { Option < crate :: prisma :: setting :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Player" , available relations are "achievements, friends_of, friends_with, scores, setting")) } ; (@ field_module ; achievements : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: achievement :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; friends_of : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: player :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; friends_with : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: player :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; scores : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: score :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; setting : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: setting :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; achievements $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: player :: IncludeParam > :: into (crate :: prisma :: player :: achievements :: Include :: $ selection_mode (crate :: prisma :: achievement :: ManyArgs :: new (crate :: prisma :: achievement :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: achievement :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; achievements $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: player :: IncludeParam > :: into (crate :: prisma :: player :: achievements :: Include :: Fetch (crate :: prisma :: achievement :: ManyArgs :: new (crate :: prisma :: achievement :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; friends_of $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: player :: IncludeParam > :: into (crate :: prisma :: player :: friends_of :: Include :: $ selection_mode (crate :: prisma :: player :: ManyArgs :: new (crate :: prisma :: player :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: player :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; friends_of $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: player :: IncludeParam > :: into (crate :: prisma :: player :: friends_of :: Include :: Fetch (crate :: prisma :: player :: ManyArgs :: new (crate :: prisma :: player :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; friends_with $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: player :: IncludeParam > :: into (crate :: prisma :: player :: friends_with :: Include :: $ selection_mode (crate :: prisma :: player :: ManyArgs :: new (crate :: prisma :: player :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: player :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; friends_with $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: player :: IncludeParam > :: into (crate :: prisma :: player :: friends_with :: Include :: Fetch (crate :: prisma :: player :: ManyArgs :: new (crate :: prisma :: player :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; scores $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: player :: IncludeParam > :: into (crate :: prisma :: player :: scores :: Include :: $ selection_mode (crate :: prisma :: score :: ManyArgs :: new (crate :: prisma :: score :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: score :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; scores $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: player :: IncludeParam > :: into (crate :: prisma :: player :: scores :: Include :: Fetch (crate :: prisma :: score :: ManyArgs :: new (crate :: prisma :: score :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; setting $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: player :: IncludeParam > :: into (crate :: prisma :: player :: setting :: Include :: $ selection_mode (crate :: prisma :: setting :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; setting $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: player :: IncludeParam > :: into (crate :: prisma :: player :: setting :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: player :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "Id" } ; (@ field_serde_name ; numeric_id) => { "NumericId" } ; (@ field_serde_name ; handle) => { "Handle" } ; (@ field_serde_name ; email) => { "Email" } ; (@ field_serde_name ; hashed_password) => { "HashedPassword" } ; (@ field_serde_name ; hashed_temporary_password) => { "HashedTemporaryPassword" } ; (@ field_serde_name ; total_play_time) => { "TotalPlayTime" } ; (@ field_serde_name ; level) => { "Level" } ; (@ field_serde_name ; exp_of_level) => { "ExpOfLevel" } ; (@ field_serde_name ; creation_date) => { "CreationDate" } ; (@ field_serde_name ; achievements) => { "Achievements" } ; (@ field_serde_name ; friends_of) => { "FriendsOf" } ; (@ field_serde_name ; friends_with) => { "FriendsWith" } ; (@ field_serde_name ; scores) => { "Scores" } ; (@ field_serde_name ; setting) => { "Setting" } ; }
    pub use _include_player as include;
    pub enum IncludeParam {
        Id(id::Include),
        NumericId(numeric_id::Include),
        Handle(handle::Include),
        Email(email::Include),
        HashedPassword(hashed_password::Include),
        HashedTemporaryPassword(hashed_temporary_password::Include),
        TotalPlayTime(total_play_time::Include),
        Level(level::Include),
        ExpOfLevel(exp_of_level::Include),
        CreationDate(creation_date::Include),
        Achievements(achievements::Include),
        FriendsOf(friends_of::Include),
        FriendsWith(friends_with::Include),
        Scores(scores::Include),
        Setting(setting::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::NumericId(data) => data.to_selection(),
                Self::Handle(data) => data.to_selection(),
                Self::Email(data) => data.to_selection(),
                Self::HashedPassword(data) => data.to_selection(),
                Self::HashedTemporaryPassword(data) => data.to_selection(),
                Self::TotalPlayTime(data) => data.to_selection(),
                Self::Level(data) => data.to_selection(),
                Self::ExpOfLevel(data) => data.to_selection(),
                Self::CreationDate(data) => data.to_selection(),
                Self::Achievements(data) => data.to_selection(),
                Self::FriendsOf(data) => data.to_selection(),
                Self::FriendsWith(data) => data.to_selection(),
                Self::Scores(data) => data.to_selection(),
                Self::Setting(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules! _partial_unchecked_player { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: player struct $ struct_name { # [serde (rename = "Id")] pub id : String , # [serde (rename = "NumericId")] pub numeric_id : i64 , # [serde (rename = "Handle")] pub handle : String , # [serde (rename = "Email")] pub email : String , # [serde (rename = "HashedPassword")] pub hashed_password : String , # [serde (rename = "HashedTemporaryPassword")] pub hashed_temporary_password : String , # [serde (rename = "TotalPlayTime")] pub total_play_time : i64 , # [serde (rename = "Level")] pub level : i64 , # [serde (rename = "ExpOfLevel")] pub exp_of_level : i64 , # [serde (rename = "CreationDate")] pub creation_date : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_player as partial_unchecked;
    #[derive(Debug, Clone, ::serde::Serialize, ::serde::Deserialize)]
    pub struct Data {
        #[serde(rename = "Id")]
        pub id: String,
        #[serde(rename = "NumericId")]
        pub numeric_id: i64,
        #[serde(rename = "Handle")]
        pub handle: String,
        #[serde(rename = "Email")]
        pub email: String,
        #[serde(rename = "HashedPassword")]
        pub hashed_password: String,
        #[serde(rename = "HashedTemporaryPassword")]
        pub hashed_temporary_password: String,
        #[serde(rename = "TotalPlayTime")]
        pub total_play_time: i64,
        #[serde(rename = "Level")]
        pub level: i64,
        #[serde(rename = "ExpOfLevel")]
        pub exp_of_level: i64,
        #[serde(rename = "CreationDate")]
        pub creation_date:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "Achievements")]
        pub achievements: Option<Vec<super::achievement::Data>>,
        #[serde(rename = "FriendsOf")]
        pub friends_of: Option<Vec<super::player::Data>>,
        #[serde(rename = "FriendsWith")]
        pub friends_with: Option<Vec<super::player::Data>>,
        #[serde(rename = "Scores")]
        pub scores: Option<Vec<super::score::Data>>,
        #[serde(
            rename = "Setting",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub setting: Option<Option<Box<super::setting::Data>>>,
    }
    impl Data {
        pub fn achievements(
            &self,
        ) -> Result<&Vec<super::achievement::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.achievements
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(achievements),
                ))
        }
        pub fn friends_of(
            &self,
        ) -> Result<&Vec<super::player::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.friends_of
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(friends_of),
                ))
        }
        pub fn friends_with(
            &self,
        ) -> Result<&Vec<super::player::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.friends_with
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(friends_with),
                ))
        }
        pub fn scores(
            &self,
        ) -> Result<&Vec<super::score::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.scores
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(scores),
                ))
        }
        pub fn setting(
            &self,
        ) -> Result<Option<&super::setting::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.setting
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(setting),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Achievements(super::achievement::ManyArgs),
        FriendsOf(super::player::ManyArgs),
        FriendsWith(super::player::ManyArgs),
        Scores(super::score::ManyArgs),
        Setting(super::setting::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Achievements(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(<super::achievement::Types as ::prisma_client_rust::ModelTypes>::scalar_selections());
                    ::prisma_client_rust::Selection::new(
                        achievements::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::FriendsOf(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(<super::player::Types as ::prisma_client_rust::ModelTypes>::scalar_selections());
                    ::prisma_client_rust::Selection::new(
                        friends_of::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::FriendsWith(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(<super::player::Types as ::prisma_client_rust::ModelTypes>::scalar_selections());
                    ::prisma_client_rust::Selection::new(
                        friends_with::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::Scores(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(<super::score::Types as ::prisma_client_rust::ModelTypes>::scalar_selections());
                    ::prisma_client_rust::Selection::new(
                        scores::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::Setting(args) => {
                    let mut selections = <super::setting::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(setting::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetNumericId(i64),
        IncrementNumericId(i64),
        DecrementNumericId(i64),
        MultiplyNumericId(i64),
        DivideNumericId(i64),
        SetHandle(String),
        SetEmail(String),
        SetHashedPassword(String),
        SetHashedTemporaryPassword(String),
        SetTotalPlayTime(i64),
        IncrementTotalPlayTime(i64),
        DecrementTotalPlayTime(i64),
        MultiplyTotalPlayTime(i64),
        DivideTotalPlayTime(i64),
        SetLevel(i64),
        IncrementLevel(i64),
        DecrementLevel(i64),
        MultiplyLevel(i64),
        DivideLevel(i64),
        SetExpOfLevel(i64),
        IncrementExpOfLevel(i64),
        DecrementExpOfLevel(i64),
        MultiplyExpOfLevel(i64),
        DivideExpOfLevel(i64),
        SetCreationDate(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        ConnectAchievements(Vec<super::achievement::UniqueWhereParam>),
        DisconnectAchievements(Vec<super::achievement::UniqueWhereParam>),
        SetAchievements(Vec<super::achievement::UniqueWhereParam>),
        ConnectFriendsOf(Vec<super::player::UniqueWhereParam>),
        DisconnectFriendsOf(Vec<super::player::UniqueWhereParam>),
        SetFriendsOf(Vec<super::player::UniqueWhereParam>),
        ConnectFriendsWith(Vec<super::player::UniqueWhereParam>),
        DisconnectFriendsWith(Vec<super::player::UniqueWhereParam>),
        SetFriendsWith(Vec<super::player::UniqueWhereParam>),
        ConnectScores(Vec<super::score::UniqueWhereParam>),
        DisconnectScores(Vec<super::score::UniqueWhereParam>),
        SetScores(Vec<super::score::UniqueWhereParam>),
        ConnectSetting(super::setting::UniqueWhereParam),
        DisconnectSetting,
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetNumericId(value) => (
                    numeric_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementNumericId(value) => (
                    numeric_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementNumericId(value) => (
                    numeric_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyNumericId(value) => (
                    numeric_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideNumericId(value) => (
                    numeric_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetHandle(value) => (
                    handle::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetEmail(value) => (
                    email::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetHashedPassword(value) => (
                    hashed_password::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetHashedTemporaryPassword(value) => (
                    hashed_temporary_password::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetTotalPlayTime(value) => (
                    total_play_time::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementTotalPlayTime(value) => (
                    total_play_time::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementTotalPlayTime(value) => (
                    total_play_time::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyTotalPlayTime(value) => (
                    total_play_time::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideTotalPlayTime(value) => (
                    total_play_time::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetLevel(value) => (
                    level::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementLevel(value) => (
                    level::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementLevel(value) => (
                    level::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyLevel(value) => (
                    level::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideLevel(value) => (
                    level::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetExpOfLevel(value) => (
                    exp_of_level::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementExpOfLevel(value) => (
                    exp_of_level::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementExpOfLevel(value) => (
                    exp_of_level::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyExpOfLevel(value) => (
                    exp_of_level::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideExpOfLevel(value) => (
                    exp_of_level::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetCreationDate(value) => (
                    creation_date::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::ConnectAchievements(where_params) => (
                    achievements::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::achievement::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectAchievements(where_params) => (
                    achievements::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::achievement::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetAchievements(where_params) => (
                    achievements::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::achievement::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectFriendsOf(where_params) => (
                    friends_of::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::player::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectFriendsOf(where_params) => (
                    friends_of::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::player::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetFriendsOf(where_params) => (
                    friends_of::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::player::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectFriendsWith(where_params) => (
                    friends_with::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::player::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectFriendsWith(where_params) => (
                    friends_with::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::player::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetFriendsWith(where_params) => (
                    friends_with::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::player::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectScores(where_params) => (
                    scores::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::score::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectScores(where_params) => (
                    scores::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::score::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetScores(where_params) => (
                    scores::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::score::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectSetting(where_param) => (
                    setting::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::setting::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectSetting => (
                    setting::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(String),
        NumericId(i64),
        Handle(String),
        Email(String),
        HashedPassword(String),
        HashedTemporaryPassword(String),
        TotalPlayTime(i64),
        Level(i64),
        ExpOfLevel(i64),
        CreationDate(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::NumericId(value) => Self::SetNumericId(value),
                UncheckedSetParam::Handle(value) => Self::SetHandle(value),
                UncheckedSetParam::Email(value) => Self::SetEmail(value),
                UncheckedSetParam::HashedPassword(value) => Self::SetHashedPassword(value),
                UncheckedSetParam::HashedTemporaryPassword(value) => {
                    Self::SetHashedTemporaryPassword(value)
                }
                UncheckedSetParam::TotalPlayTime(value) => Self::SetTotalPlayTime(value),
                UncheckedSetParam::Level(value) => Self::SetLevel(value),
                UncheckedSetParam::ExpOfLevel(value) => Self::SetExpOfLevel(value),
                UncheckedSetParam::CreationDate(value) => Self::SetCreationDate(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        NumericId(::prisma_client_rust::Direction),
        Handle(::prisma_client_rust::Direction),
        Email(::prisma_client_rust::Direction),
        HashedPassword(::prisma_client_rust::Direction),
        HashedTemporaryPassword(::prisma_client_rust::Direction),
        TotalPlayTime(::prisma_client_rust::Direction),
        Level(::prisma_client_rust::Direction),
        ExpOfLevel(::prisma_client_rust::Direction),
        CreationDate(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::NumericId(direction) => (
                    numeric_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Handle(direction) => (
                    handle::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Email(direction) => (
                    email::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::HashedPassword(direction) => (
                    hashed_password::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::HashedTemporaryPassword(direction) => (
                    hashed_temporary_password::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::TotalPlayTime(direction) => (
                    total_play_time::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Level(direction) => (
                    level::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ExpOfLevel(direction) => (
                    exp_of_level::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreationDate(direction) => (
                    creation_date::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::StringFilter),
        NumericId(_prisma::read_filters::BigIntFilter),
        Handle(_prisma::read_filters::StringFilter),
        Email(_prisma::read_filters::StringFilter),
        HashedPassword(_prisma::read_filters::StringFilter),
        HashedTemporaryPassword(_prisma::read_filters::StringFilter),
        TotalPlayTime(_prisma::read_filters::BigIntFilter),
        Level(_prisma::read_filters::BigIntFilter),
        ExpOfLevel(_prisma::read_filters::BigIntFilter),
        CreationDate(_prisma::read_filters::DateTimeFilter),
        AchievementsSome(Vec<super::achievement::WhereParam>),
        AchievementsEvery(Vec<super::achievement::WhereParam>),
        AchievementsNone(Vec<super::achievement::WhereParam>),
        FriendsOfSome(Vec<super::player::WhereParam>),
        FriendsOfEvery(Vec<super::player::WhereParam>),
        FriendsOfNone(Vec<super::player::WhereParam>),
        FriendsWithSome(Vec<super::player::WhereParam>),
        FriendsWithEvery(Vec<super::player::WhereParam>),
        FriendsWithNone(Vec<super::player::WhereParam>),
        ScoresSome(Vec<super::score::WhereParam>),
        ScoresEvery(Vec<super::score::WhereParam>),
        ScoresNone(Vec<super::score::WhereParam>),
        SettingIsNull,
        SettingIs(Vec<super::setting::WhereParam>),
        SettingIsNot(Vec<super::setting::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::NumericId(value) => (numeric_id::NAME, value.into()),
                Self::Handle(value) => (handle::NAME, value.into()),
                Self::Email(value) => (email::NAME, value.into()),
                Self::HashedPassword(value) => (hashed_password::NAME, value.into()),
                Self::HashedTemporaryPassword(value) => {
                    (hashed_temporary_password::NAME, value.into())
                }
                Self::TotalPlayTime(value) => (total_play_time::NAME, value.into()),
                Self::Level(value) => (level::NAME, value.into()),
                Self::ExpOfLevel(value) => (exp_of_level::NAME, value.into()),
                Self::CreationDate(value) => (creation_date::NAME, value.into()),
                Self::AchievementsSome(where_params) => (
                    achievements::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::AchievementsEvery(where_params) => (
                    achievements::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::AchievementsNone(where_params) => (
                    achievements::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::FriendsOfSome(where_params) => (
                    friends_of::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::FriendsOfEvery(where_params) => (
                    friends_of::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::FriendsOfNone(where_params) => (
                    friends_of::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::FriendsWithSome(where_params) => (
                    friends_with::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::FriendsWithEvery(where_params) => (
                    friends_with::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::FriendsWithNone(where_params) => (
                    friends_with::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ScoresSome(where_params) => (
                    scores::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ScoresEvery(where_params) => (
                    scores::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ScoresNone(where_params) => (
                    scores::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::SettingIsNull => (
                    setting::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::Null,
                    ),
                ),
                Self::SettingIs(where_params) => (
                    setting::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::SettingIsNot(where_params) => (
                    setting::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::StringFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(numeric_id::NAME),
                ::prisma_client_rust::sel(handle::NAME),
                ::prisma_client_rust::sel(email::NAME),
                ::prisma_client_rust::sel(hashed_password::NAME),
                ::prisma_client_rust::sel(hashed_temporary_password::NAME),
                ::prisma_client_rust::sel(total_play_time::NAME),
                ::prisma_client_rust::sel(level::NAME),
                ::prisma_client_rust::sel(exp_of_level::NAME),
                ::prisma_client_rust::sel(creation_date::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            numeric_id: i64,
            handle: String,
            email: String,
            hashed_password: String,
            hashed_temporary_password: String,
            total_play_time: i64,
            level: i64,
            exp_of_level: i64,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                numeric_id::set(numeric_id),
                handle::set(handle),
                email::set(email),
                hashed_password::set(hashed_password),
                hashed_temporary_password::set(hashed_temporary_password),
                total_play_time::set(total_play_time),
                level::set(level),
                exp_of_level::set(exp_of_level),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            numeric_id: i64,
            handle: String,
            email: String,
            hashed_password: String,
            hashed_temporary_password: String,
            total_play_time: i64,
            level: i64,
            exp_of_level: i64,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                numeric_id::set(numeric_id),
                handle::set(handle),
                email::set(email),
                hashed_password::set(hashed_password),
                hashed_temporary_password::set(hashed_temporary_password),
                total_play_time::set(total_play_time),
                level::set(level),
                exp_of_level::set(exp_of_level),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (
                numeric_id,
                handle,
                email,
                hashed_password,
                hashed_temporary_password,
                total_play_time,
                level,
                exp_of_level,
                mut _params,
            ): (
                i64,
                String,
                String,
                String,
                String,
                i64,
                i64,
                i64,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                numeric_id::set(numeric_id),
                handle::set(handle),
                email::set(email),
                hashed_password::set(hashed_password),
                hashed_temporary_password::set(hashed_temporary_password),
                total_play_time::set(total_play_time),
                level::set(level),
                exp_of_level::set(exp_of_level),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod achievement {
    use super::*;
    pub const NAME: &str = "Achievement";
    pub mod id {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
        };
        pub const NAME: &str = "Id";
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i64) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BigIntFilter, Id, {
            fn in_vec(_: Vec<i64>) -> InVec;
            fn not_in_vec(_: Vec<i64>) -> NotInVec;
            fn lt(_: i64) -> Lt;
            fn lte(_: i64) -> Lte;
            fn gt(_: i64) -> Gt;
            fn gte(_: i64) -> Gte;
            fn not(_: i64) -> Not;
        });
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "Name";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Name(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Name(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Name(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod detail {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "Detail";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetDetail(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Detail(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Detail(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Detail(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Detail,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Detail(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Detail(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod favor_text {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "FavorText";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetFavorText(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::FavorText(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::FavorText(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::FavorText(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            FavorText,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::FavorText(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::FavorText(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod players {
        use super::super::*;
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "Players";
        pub struct Fetch(pub player::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<player::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: player::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: player::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Players(v)
            }
        }
        pub fn fetch(params: Vec<player::WhereParam>) -> Fetch {
            Fetch(player::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<player::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectPlayers(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<player::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<player::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectPlayers(params)
        }
        pub fn set(params: Vec<player::UniqueWhereParam>) -> SetParam {
            SetParam::SetPlayers(params)
        }
        pub fn some(value: Vec<player::WhereParam>) -> WhereParam {
            WhereParam::PlayersSome(value)
        }
        pub fn every(value: Vec<player::WhereParam>) -> WhereParam {
            WhereParam::PlayersEvery(value)
        }
        pub fn none(value: Vec<player::WhereParam>) -> WhereParam {
            WhereParam::PlayersNone(value)
        }
        pub enum Include {
            Select(player::ManyArgs, Vec<player::SelectParam>),
            Include(player::ManyArgs, Vec<player::IncludeParam>),
            Fetch(player::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Players(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections =
                            <player::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <player::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: player::ManyArgs,
                nested_selections: Vec<player::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: player::ManyArgs,
                nested_selections: Vec<player::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(player::ManyArgs, Vec<player::SelectParam>),
            Include(player::ManyArgs, Vec<player::IncludeParam>),
            Fetch(player::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Players(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <player::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: player::ManyArgs,
                nested_selections: Vec<player::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: player::ManyArgs,
                nested_selections: Vec<player::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn create(
        id: i64,
        name: String,
        detail: String,
        favor_text: String,
        _params: Vec<SetParam>,
    ) -> (i64, String, String, String, Vec<SetParam>) {
        (id, name, detail, favor_text, _params)
    }
    pub fn create_unchecked(
        id: i64,
        name: String,
        detail: String,
        favor_text: String,
        _params: Vec<SetParam>,
    ) -> (i64, String, String, String, Vec<SetParam>) {
        (id, name, detail, favor_text, _params)
    }
    #[macro_export]
    macro_rules! _select_achievement { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: achievement :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: achievement :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: achievement :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: achievement :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: achievement :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: achievement :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , name , detail , favor_text , players } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: achievement :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: achievement :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: achievement :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: achievement :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: achievement :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: achievement :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["Id" , "Name" , "Detail" , "FavorText" , "Players"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: achievement :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i64 } ; (@ field_type ; name) => { String } ; (@ field_type ; detail) => { String } ; (@ field_type ; favor_text) => { String } ; (@ field_type ; players : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < players :: Data > } ; (@ field_type ; players) => { Vec < crate :: prisma :: player :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Achievement" , available relations are "id, name, detail, favor_text, players")) } ; (@ field_module ; players : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: player :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: achievement :: SelectParam > :: into (crate :: prisma :: achievement :: id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: achievement :: SelectParam > :: into (crate :: prisma :: achievement :: name :: Select) } ; (@ selection_field_to_selection_param ; detail) => { Into :: < crate :: prisma :: achievement :: SelectParam > :: into (crate :: prisma :: achievement :: detail :: Select) } ; (@ selection_field_to_selection_param ; favor_text) => { Into :: < crate :: prisma :: achievement :: SelectParam > :: into (crate :: prisma :: achievement :: favor_text :: Select) } ; (@ selection_field_to_selection_param ; players $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: achievement :: SelectParam > :: into (crate :: prisma :: achievement :: players :: Select :: $ selection_mode (crate :: prisma :: player :: ManyArgs :: new (crate :: prisma :: player :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: player :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; players $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: achievement :: SelectParam > :: into (crate :: prisma :: achievement :: players :: Select :: Fetch (crate :: prisma :: player :: ManyArgs :: new (crate :: prisma :: player :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: achievement :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "Id" } ; (@ field_serde_name ; name) => { "Name" } ; (@ field_serde_name ; detail) => { "Detail" } ; (@ field_serde_name ; favor_text) => { "FavorText" } ; (@ field_serde_name ; players) => { "Players" } ; }
    pub use _select_achievement as select;
    pub enum SelectParam {
        Id(id::Select),
        Name(name::Select),
        Detail(detail::Select),
        FavorText(favor_text::Select),
        Players(players::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Detail(data) => data.to_selection(),
                Self::FavorText(data) => data.to_selection(),
                Self::Players(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules! _include_achievement { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: achievement :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: achievement :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: achievement :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: achievement :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: achievement :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: achievement :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: achievement :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: achievement :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { players } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i64 , pub name : String , pub detail : String , pub favor_text : String , $ (pub $ field : crate :: prisma :: achievement :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (name) , stringify ! (detail) , stringify ! (favor_text)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: achievement :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: achievement :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: achievement :: name :: NAME , & self . name) ? ; state . serialize_field (crate :: prisma :: achievement :: detail :: NAME , & self . detail) ? ; state . serialize_field (crate :: prisma :: achievement :: favor_text :: NAME , & self . favor_text) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , name , detail , favor_text } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: achievement :: $ field :: NAME) , + , crate :: prisma :: achievement :: id :: NAME , crate :: prisma :: achievement :: name :: NAME , crate :: prisma :: achievement :: detail :: NAME , crate :: prisma :: achievement :: favor_text :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: achievement :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: achievement :: id :: NAME => Ok (Field :: id) , crate :: prisma :: achievement :: name :: NAME => Ok (Field :: name) , crate :: prisma :: achievement :: detail :: NAME => Ok (Field :: detail) , crate :: prisma :: achievement :: favor_text :: NAME => Ok (Field :: favor_text) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut name = None ; let mut detail = None ; let mut favor_text = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: achievement :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: achievement :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: detail => { if detail . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: achievement :: detail :: NAME)) ; } detail = Some (map . next_value () ?) ; } Field :: favor_text => { if favor_text . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: achievement :: favor_text :: NAME)) ; } favor_text = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: achievement :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: achievement :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: achievement :: id :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: achievement :: name :: NAME)) ? ; let detail = detail . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: achievement :: detail :: NAME)) ? ; let favor_text = favor_text . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: achievement :: favor_text :: NAME)) ? ; Ok (Data { id , name , detail , favor_text , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["Id" , "Name" , "Detail" , "FavorText" , "Players"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: achievement :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; players : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < players :: Data > } ; (@ field_type ; players) => { Vec < crate :: prisma :: player :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Achievement" , available relations are "players")) } ; (@ field_module ; players : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: player :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; players $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: achievement :: IncludeParam > :: into (crate :: prisma :: achievement :: players :: Include :: $ selection_mode (crate :: prisma :: player :: ManyArgs :: new (crate :: prisma :: player :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: player :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; players $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: achievement :: IncludeParam > :: into (crate :: prisma :: achievement :: players :: Include :: Fetch (crate :: prisma :: player :: ManyArgs :: new (crate :: prisma :: player :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: achievement :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "Id" } ; (@ field_serde_name ; name) => { "Name" } ; (@ field_serde_name ; detail) => { "Detail" } ; (@ field_serde_name ; favor_text) => { "FavorText" } ; (@ field_serde_name ; players) => { "Players" } ; }
    pub use _include_achievement as include;
    pub enum IncludeParam {
        Id(id::Include),
        Name(name::Include),
        Detail(detail::Include),
        FavorText(favor_text::Include),
        Players(players::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Detail(data) => data.to_selection(),
                Self::FavorText(data) => data.to_selection(),
                Self::Players(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules! _partial_unchecked_achievement { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: achievement struct $ struct_name { # [serde (rename = "Id")] pub id : i64 , # [serde (rename = "Name")] pub name : String , # [serde (rename = "Detail")] pub detail : String , # [serde (rename = "FavorText")] pub favor_text : String } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_achievement as partial_unchecked;
    #[derive(Debug, Clone, ::serde::Serialize, ::serde::Deserialize)]
    pub struct Data {
        #[serde(rename = "Id")]
        pub id: i64,
        #[serde(rename = "Name")]
        pub name: String,
        #[serde(rename = "Detail")]
        pub detail: String,
        #[serde(rename = "FavorText")]
        pub favor_text: String,
        #[serde(rename = "Players")]
        pub players: Option<Vec<super::player::Data>>,
    }
    impl Data {
        pub fn players(
            &self,
        ) -> Result<&Vec<super::player::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.players
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(players),
                ))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Players(super::player::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Players(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(<super::player::Types as ::prisma_client_rust::ModelTypes>::scalar_selections());
                    ::prisma_client_rust::Selection::new(
                        players::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i64),
        IncrementId(i64),
        DecrementId(i64),
        MultiplyId(i64),
        DivideId(i64),
        SetName(String),
        SetDetail(String),
        SetFavorText(String),
        ConnectPlayers(Vec<super::player::UniqueWhereParam>),
        DisconnectPlayers(Vec<super::player::UniqueWhereParam>),
        SetPlayers(Vec<super::player::UniqueWhereParam>),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetName(value) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetDetail(value) => (
                    detail::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetFavorText(value) => (
                    favor_text::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectPlayers(where_params) => (
                    players::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::player::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectPlayers(where_params) => (
                    players::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::player::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetPlayers(where_params) => (
                    players::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::player::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i64),
        Name(String),
        Detail(String),
        FavorText(String),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::Name(value) => Self::SetName(value),
                UncheckedSetParam::Detail(value) => Self::SetDetail(value),
                UncheckedSetParam::FavorText(value) => Self::SetFavorText(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Name(::prisma_client_rust::Direction),
        Detail(::prisma_client_rust::Direction),
        FavorText(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Name(direction) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Detail(direction) => (
                    detail::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::FavorText(direction) => (
                    favor_text::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::BigIntFilter),
        Name(_prisma::read_filters::StringFilter),
        Detail(_prisma::read_filters::StringFilter),
        FavorText(_prisma::read_filters::StringFilter),
        PlayersSome(Vec<super::player::WhereParam>),
        PlayersEvery(Vec<super::player::WhereParam>),
        PlayersNone(Vec<super::player::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::Name(value) => (name::NAME, value.into()),
                Self::Detail(value) => (detail::NAME, value.into()),
                Self::FavorText(value) => (favor_text::NAME, value.into()),
                Self::PlayersSome(where_params) => (
                    players::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::PlayersEvery(where_params) => (
                    players::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::PlayersNone(where_params) => (
                    players::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i64),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::BigIntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(name::NAME),
                ::prisma_client_rust::sel(detail::NAME),
                ::prisma_client_rust::sel(favor_text::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            id: i64,
            name: String,
            detail: String,
            favor_text: String,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                id::set(id),
                name::set(name),
                detail::set(detail),
                favor_text::set(favor_text),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            id: i64,
            name: String,
            detail: String,
            favor_text: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                id::set(id),
                name::set(name),
                detail::set(detail),
                favor_text::set(favor_text),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (id, name, detail, favor_text, mut _params): (
                i64,
                String,
                String,
                String,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                id::set(id),
                name::set(name),
                detail::set(detail),
                favor_text::set(favor_text),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod score {
    use super::*;
    pub const NAME: &str = "Score";
    pub mod id {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
        };
        pub const NAME: &str = "Id";
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i64) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BigIntFilter, Id, {
            fn in_vec(_: Vec<i64>) -> InVec;
            fn not_in_vec(_: Vec<i64>) -> NotInVec;
            fn lt(_: i64) -> Lt;
            fn lte(_: i64) -> Lte;
            fn gt(_: i64) -> Gt;
            fn gte(_: i64) -> Gte;
            fn not(_: i64) -> Not;
        });
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod track_id {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "TrackId";
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTrackId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::TrackId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::TrackId(direction)
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::TrackId(_prisma::read_filters::BigIntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BigIntFilter,
            TrackId,
            {
                fn in_vec(_: Vec<i64>) -> InVec;
                fn not_in_vec(_: Vec<i64>) -> NotInVec;
                fn lt(_: i64) -> Lt;
                fn lte(_: i64) -> Lte;
                fn gt(_: i64) -> Gt;
                fn gte(_: i64) -> Gte;
                fn not(_: i64) -> Not;
            }
        );
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementTrackId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementTrackId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyTrackId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideTrackId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::TrackId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::TrackId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod track_name {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "TrackName";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTrackName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::TrackName(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::TrackName(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::TrackName(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            TrackName,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::TrackName(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::TrackName(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod total_points {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "TotalPoints";
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTotalPoints(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::TotalPoints(v)
            }
        }
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::TotalPoints(direction)
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::TotalPoints(_prisma::read_filters::BigIntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BigIntFilter,
            TotalPoints,
            {
                fn in_vec(_: Vec<i64>) -> InVec;
                fn not_in_vec(_: Vec<i64>) -> NotInVec;
                fn lt(_: i64) -> Lt;
                fn lte(_: i64) -> Lte;
                fn gt(_: i64) -> Gt;
                fn gte(_: i64) -> Gte;
                fn not(_: i64) -> Not;
            }
        );
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementTotalPoints(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementTotalPoints(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyTotalPoints(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideTotalPoints(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::TotalPoints(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::TotalPoints(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod accuracy {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "Accuracy";
        pub struct Set(pub f64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetAccuracy(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Accuracy(v)
            }
        }
        pub fn set<T: From<Set>>(value: f64) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Accuracy(direction)
        }
        pub fn equals(value: f64) -> WhereParam {
            WhereParam::Accuracy(_prisma::read_filters::FloatFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::FloatFilter,
            Accuracy,
            {
                fn in_vec(_: Vec<f64>) -> InVec;
                fn not_in_vec(_: Vec<f64>) -> NotInVec;
                fn lt(_: f64) -> Lt;
                fn lte(_: f64) -> Lte;
                fn gt(_: f64) -> Gt;
                fn gte(_: f64) -> Gte;
                fn not(_: f64) -> Not;
            }
        );
        pub fn increment(value: f64) -> SetParam {
            SetParam::IncrementAccuracy(value)
        }
        pub fn decrement(value: f64) -> SetParam {
            SetParam::DecrementAccuracy(value)
        }
        pub fn multiply(value: f64) -> SetParam {
            SetParam::MultiplyAccuracy(value)
        }
        pub fn divide(value: f64) -> SetParam {
            SetParam::DivideAccuracy(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Accuracy(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Accuracy(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod critical {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "Critical";
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCritical(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Critical(v)
            }
        }
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Critical(direction)
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::Critical(_prisma::read_filters::BigIntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BigIntFilter,
            Critical,
            {
                fn in_vec(_: Vec<i64>) -> InVec;
                fn not_in_vec(_: Vec<i64>) -> NotInVec;
                fn lt(_: i64) -> Lt;
                fn lte(_: i64) -> Lte;
                fn gt(_: i64) -> Gt;
                fn gte(_: i64) -> Gte;
                fn not(_: i64) -> Not;
            }
        );
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementCritical(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementCritical(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyCritical(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideCritical(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Critical(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Critical(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod max_combo {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "MaxCombo";
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetMaxCombo(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::MaxCombo(v)
            }
        }
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::MaxCombo(direction)
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::MaxCombo(_prisma::read_filters::BigIntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BigIntFilter,
            MaxCombo,
            {
                fn in_vec(_: Vec<i64>) -> InVec;
                fn not_in_vec(_: Vec<i64>) -> NotInVec;
                fn lt(_: i64) -> Lt;
                fn lte(_: i64) -> Lte;
                fn gt(_: i64) -> Gt;
                fn gte(_: i64) -> Gte;
                fn not(_: i64) -> Not;
            }
        );
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementMaxCombo(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementMaxCombo(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyMaxCombo(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideMaxCombo(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::MaxCombo(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::MaxCombo(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod grade {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "Grade";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetGrade(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Grade(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Grade(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Grade(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Grade,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Grade(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Grade(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod perfect {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "Perfect";
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetPerfect(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Perfect(v)
            }
        }
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Perfect(direction)
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::Perfect(_prisma::read_filters::BigIntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BigIntFilter,
            Perfect,
            {
                fn in_vec(_: Vec<i64>) -> InVec;
                fn not_in_vec(_: Vec<i64>) -> NotInVec;
                fn lt(_: i64) -> Lt;
                fn lte(_: i64) -> Lte;
                fn gt(_: i64) -> Gt;
                fn gte(_: i64) -> Gte;
                fn not(_: i64) -> Not;
            }
        );
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementPerfect(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementPerfect(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyPerfect(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DividePerfect(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Perfect(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Perfect(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod good {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "Good";
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetGood(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Good(v)
            }
        }
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Good(direction)
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::Good(_prisma::read_filters::BigIntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BigIntFilter, Good, {
            fn in_vec(_: Vec<i64>) -> InVec;
            fn not_in_vec(_: Vec<i64>) -> NotInVec;
            fn lt(_: i64) -> Lt;
            fn lte(_: i64) -> Lte;
            fn gt(_: i64) -> Gt;
            fn gte(_: i64) -> Gte;
            fn not(_: i64) -> Not;
        });
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementGood(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementGood(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyGood(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideGood(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Good(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Good(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod bad {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "Bad";
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetBad(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Bad(v)
            }
        }
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Bad(direction)
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::Bad(_prisma::read_filters::BigIntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BigIntFilter, Bad, {
            fn in_vec(_: Vec<i64>) -> InVec;
            fn not_in_vec(_: Vec<i64>) -> NotInVec;
            fn lt(_: i64) -> Lt;
            fn lte(_: i64) -> Lte;
            fn gt(_: i64) -> Gt;
            fn gte(_: i64) -> Gte;
            fn not(_: i64) -> Not;
        });
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementBad(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementBad(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyBad(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideBad(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Bad(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Bad(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod miss {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "Miss";
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetMiss(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Miss(v)
            }
        }
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Miss(direction)
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::Miss(_prisma::read_filters::BigIntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BigIntFilter, Miss, {
            fn in_vec(_: Vec<i64>) -> InVec;
            fn not_in_vec(_: Vec<i64>) -> NotInVec;
            fn lt(_: i64) -> Lt;
            fn lte(_: i64) -> Lte;
            fn gt(_: i64) -> Gt;
            fn gte(_: i64) -> Gte;
            fn not(_: i64) -> Not;
        });
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementMiss(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementMiss(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyMiss(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideMiss(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Miss(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Miss(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod raw_json {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "RawJson";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetRawJson(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::RawJson(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::RawJson(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::RawJson(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            RawJson,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::RawJson(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::RawJson(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod submission_date {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "SubmissionDate";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetSubmissionDate(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::SubmissionDate(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::SubmissionDate(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::SubmissionDate(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            SubmissionDate,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::SubmissionDate(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::SubmissionDate(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod player_id {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "PlayerId";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetPlayerId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::PlayerId(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::PlayerId(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::PlayerId(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            PlayerId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::PlayerId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::PlayerId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod player {
        use super::super::*;
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "Player";
        pub struct Fetch(pub player::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<player::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Player(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(player::UniqueArgs::new())
        }
        pub struct Connect(player::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectPlayer(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: player::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<player::WhereParam>) -> WhereParam {
            WhereParam::PlayerIs(value)
        }
        pub fn is_not(value: Vec<player::WhereParam>) -> WhereParam {
            WhereParam::PlayerIsNot(value)
        }
        pub enum Include {
            Select(Vec<player::SelectParam>),
            Include(Vec<player::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Player(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <player::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <player::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("Player", None, [], selections)
            }
            pub fn select(nested_selections: Vec<player::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<player::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<player::SelectParam>),
            Include(Vec<player::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Player(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <player::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("Player", None, [], selections)
            }
            pub fn select(nested_selections: Vec<player::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<player::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(
        track_id: i64,
        track_name: String,
        total_points: i64,
        accuracy: f64,
        critical: i64,
        max_combo: i64,
        grade: String,
        perfect: i64,
        good: i64,
        bad: i64,
        miss: i64,
        raw_json: String,
        submission_date: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        player: super::player::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        i64,
        String,
        i64,
        f64,
        i64,
        i64,
        String,
        i64,
        i64,
        i64,
        i64,
        String,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        super::player::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (
            track_id,
            track_name,
            total_points,
            accuracy,
            critical,
            max_combo,
            grade,
            perfect,
            good,
            bad,
            miss,
            raw_json,
            submission_date,
            player,
            _params,
        )
    }
    pub fn create_unchecked(
        track_id: i64,
        track_name: String,
        total_points: i64,
        accuracy: f64,
        critical: i64,
        max_combo: i64,
        grade: String,
        perfect: i64,
        good: i64,
        bad: i64,
        miss: i64,
        raw_json: String,
        submission_date: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        player_id: String,
        _params: Vec<SetParam>,
    ) -> (
        i64,
        String,
        i64,
        f64,
        i64,
        i64,
        String,
        i64,
        i64,
        i64,
        i64,
        String,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        String,
        Vec<SetParam>,
    ) {
        (
            track_id,
            track_name,
            total_points,
            accuracy,
            critical,
            max_combo,
            grade,
            perfect,
            good,
            bad,
            miss,
            raw_json,
            submission_date,
            player_id,
            _params,
        )
    }
    #[macro_export]
    macro_rules! _select_score { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: score :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: score :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: score :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: score :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: score :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: score :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , track_id , track_name , total_points , accuracy , critical , max_combo , grade , perfect , good , bad , miss , raw_json , submission_date , player_id , player } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: score :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: score :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: score :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: score :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: score :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: score :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["Id" , "TrackId" , "TrackName" , "TotalPoints" , "Accuracy" , "Critical" , "MaxCombo" , "Grade" , "Perfect" , "Good" , "Bad" , "Miss" , "RawJson" , "SubmissionDate" , "PlayerId" , "Player"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: score :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i64 } ; (@ field_type ; track_id) => { i64 } ; (@ field_type ; track_name) => { String } ; (@ field_type ; total_points) => { i64 } ; (@ field_type ; accuracy) => { f64 } ; (@ field_type ; critical) => { i64 } ; (@ field_type ; max_combo) => { i64 } ; (@ field_type ; grade) => { String } ; (@ field_type ; perfect) => { i64 } ; (@ field_type ; good) => { i64 } ; (@ field_type ; bad) => { i64 } ; (@ field_type ; miss) => { i64 } ; (@ field_type ; raw_json) => { String } ; (@ field_type ; submission_date) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; player_id) => { String } ; (@ field_type ; player : $ selection_mode : ident { $ ($ selections : tt) + }) => { player :: Data } ; (@ field_type ; player) => { crate :: prisma :: player :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Score" , available relations are "id, track_id, track_name, total_points, accuracy, critical, max_combo, grade, perfect, good, bad, miss, raw_json, submission_date, player_id, player")) } ; (@ field_module ; player : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: player :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: score :: SelectParam > :: into (crate :: prisma :: score :: id :: Select) } ; (@ selection_field_to_selection_param ; track_id) => { Into :: < crate :: prisma :: score :: SelectParam > :: into (crate :: prisma :: score :: track_id :: Select) } ; (@ selection_field_to_selection_param ; track_name) => { Into :: < crate :: prisma :: score :: SelectParam > :: into (crate :: prisma :: score :: track_name :: Select) } ; (@ selection_field_to_selection_param ; total_points) => { Into :: < crate :: prisma :: score :: SelectParam > :: into (crate :: prisma :: score :: total_points :: Select) } ; (@ selection_field_to_selection_param ; accuracy) => { Into :: < crate :: prisma :: score :: SelectParam > :: into (crate :: prisma :: score :: accuracy :: Select) } ; (@ selection_field_to_selection_param ; critical) => { Into :: < crate :: prisma :: score :: SelectParam > :: into (crate :: prisma :: score :: critical :: Select) } ; (@ selection_field_to_selection_param ; max_combo) => { Into :: < crate :: prisma :: score :: SelectParam > :: into (crate :: prisma :: score :: max_combo :: Select) } ; (@ selection_field_to_selection_param ; grade) => { Into :: < crate :: prisma :: score :: SelectParam > :: into (crate :: prisma :: score :: grade :: Select) } ; (@ selection_field_to_selection_param ; perfect) => { Into :: < crate :: prisma :: score :: SelectParam > :: into (crate :: prisma :: score :: perfect :: Select) } ; (@ selection_field_to_selection_param ; good) => { Into :: < crate :: prisma :: score :: SelectParam > :: into (crate :: prisma :: score :: good :: Select) } ; (@ selection_field_to_selection_param ; bad) => { Into :: < crate :: prisma :: score :: SelectParam > :: into (crate :: prisma :: score :: bad :: Select) } ; (@ selection_field_to_selection_param ; miss) => { Into :: < crate :: prisma :: score :: SelectParam > :: into (crate :: prisma :: score :: miss :: Select) } ; (@ selection_field_to_selection_param ; raw_json) => { Into :: < crate :: prisma :: score :: SelectParam > :: into (crate :: prisma :: score :: raw_json :: Select) } ; (@ selection_field_to_selection_param ; submission_date) => { Into :: < crate :: prisma :: score :: SelectParam > :: into (crate :: prisma :: score :: submission_date :: Select) } ; (@ selection_field_to_selection_param ; player_id) => { Into :: < crate :: prisma :: score :: SelectParam > :: into (crate :: prisma :: score :: player_id :: Select) } ; (@ selection_field_to_selection_param ; player $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: score :: SelectParam > :: into (crate :: prisma :: score :: player :: Select :: $ selection_mode (crate :: prisma :: player :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; player $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: score :: SelectParam > :: into (crate :: prisma :: score :: player :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: score :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "Id" } ; (@ field_serde_name ; track_id) => { "TrackId" } ; (@ field_serde_name ; track_name) => { "TrackName" } ; (@ field_serde_name ; total_points) => { "TotalPoints" } ; (@ field_serde_name ; accuracy) => { "Accuracy" } ; (@ field_serde_name ; critical) => { "Critical" } ; (@ field_serde_name ; max_combo) => { "MaxCombo" } ; (@ field_serde_name ; grade) => { "Grade" } ; (@ field_serde_name ; perfect) => { "Perfect" } ; (@ field_serde_name ; good) => { "Good" } ; (@ field_serde_name ; bad) => { "Bad" } ; (@ field_serde_name ; miss) => { "Miss" } ; (@ field_serde_name ; raw_json) => { "RawJson" } ; (@ field_serde_name ; submission_date) => { "SubmissionDate" } ; (@ field_serde_name ; player_id) => { "PlayerId" } ; (@ field_serde_name ; player) => { "Player" } ; }
    pub use _select_score as select;
    pub enum SelectParam {
        Id(id::Select),
        TrackId(track_id::Select),
        TrackName(track_name::Select),
        TotalPoints(total_points::Select),
        Accuracy(accuracy::Select),
        Critical(critical::Select),
        MaxCombo(max_combo::Select),
        Grade(grade::Select),
        Perfect(perfect::Select),
        Good(good::Select),
        Bad(bad::Select),
        Miss(miss::Select),
        RawJson(raw_json::Select),
        SubmissionDate(submission_date::Select),
        PlayerId(player_id::Select),
        Player(player::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::TrackId(data) => data.to_selection(),
                Self::TrackName(data) => data.to_selection(),
                Self::TotalPoints(data) => data.to_selection(),
                Self::Accuracy(data) => data.to_selection(),
                Self::Critical(data) => data.to_selection(),
                Self::MaxCombo(data) => data.to_selection(),
                Self::Grade(data) => data.to_selection(),
                Self::Perfect(data) => data.to_selection(),
                Self::Good(data) => data.to_selection(),
                Self::Bad(data) => data.to_selection(),
                Self::Miss(data) => data.to_selection(),
                Self::RawJson(data) => data.to_selection(),
                Self::SubmissionDate(data) => data.to_selection(),
                Self::PlayerId(data) => data.to_selection(),
                Self::Player(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules! _include_score { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: score :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: score :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: score :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: score :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: score :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: score :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: score :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: score :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { player } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i64 , pub track_id : i64 , pub track_name : String , pub total_points : i64 , pub accuracy : f64 , pub critical : i64 , pub max_combo : i64 , pub grade : String , pub perfect : i64 , pub good : i64 , pub bad : i64 , pub miss : i64 , pub raw_json : String , pub submission_date : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub player_id : String , $ (pub $ field : crate :: prisma :: score :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (track_id) , stringify ! (track_name) , stringify ! (total_points) , stringify ! (accuracy) , stringify ! (critical) , stringify ! (max_combo) , stringify ! (grade) , stringify ! (perfect) , stringify ! (good) , stringify ! (bad) , stringify ! (miss) , stringify ! (raw_json) , stringify ! (submission_date) , stringify ! (player_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: score :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: score :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: score :: track_id :: NAME , & self . track_id) ? ; state . serialize_field (crate :: prisma :: score :: track_name :: NAME , & self . track_name) ? ; state . serialize_field (crate :: prisma :: score :: total_points :: NAME , & self . total_points) ? ; state . serialize_field (crate :: prisma :: score :: accuracy :: NAME , & self . accuracy) ? ; state . serialize_field (crate :: prisma :: score :: critical :: NAME , & self . critical) ? ; state . serialize_field (crate :: prisma :: score :: max_combo :: NAME , & self . max_combo) ? ; state . serialize_field (crate :: prisma :: score :: grade :: NAME , & self . grade) ? ; state . serialize_field (crate :: prisma :: score :: perfect :: NAME , & self . perfect) ? ; state . serialize_field (crate :: prisma :: score :: good :: NAME , & self . good) ? ; state . serialize_field (crate :: prisma :: score :: bad :: NAME , & self . bad) ? ; state . serialize_field (crate :: prisma :: score :: miss :: NAME , & self . miss) ? ; state . serialize_field (crate :: prisma :: score :: raw_json :: NAME , & self . raw_json) ? ; state . serialize_field (crate :: prisma :: score :: submission_date :: NAME , & self . submission_date) ? ; state . serialize_field (crate :: prisma :: score :: player_id :: NAME , & self . player_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , track_id , track_name , total_points , accuracy , critical , max_combo , grade , perfect , good , bad , miss , raw_json , submission_date , player_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: score :: $ field :: NAME) , + , crate :: prisma :: score :: id :: NAME , crate :: prisma :: score :: track_id :: NAME , crate :: prisma :: score :: track_name :: NAME , crate :: prisma :: score :: total_points :: NAME , crate :: prisma :: score :: accuracy :: NAME , crate :: prisma :: score :: critical :: NAME , crate :: prisma :: score :: max_combo :: NAME , crate :: prisma :: score :: grade :: NAME , crate :: prisma :: score :: perfect :: NAME , crate :: prisma :: score :: good :: NAME , crate :: prisma :: score :: bad :: NAME , crate :: prisma :: score :: miss :: NAME , crate :: prisma :: score :: raw_json :: NAME , crate :: prisma :: score :: submission_date :: NAME , crate :: prisma :: score :: player_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: score :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: score :: id :: NAME => Ok (Field :: id) , crate :: prisma :: score :: track_id :: NAME => Ok (Field :: track_id) , crate :: prisma :: score :: track_name :: NAME => Ok (Field :: track_name) , crate :: prisma :: score :: total_points :: NAME => Ok (Field :: total_points) , crate :: prisma :: score :: accuracy :: NAME => Ok (Field :: accuracy) , crate :: prisma :: score :: critical :: NAME => Ok (Field :: critical) , crate :: prisma :: score :: max_combo :: NAME => Ok (Field :: max_combo) , crate :: prisma :: score :: grade :: NAME => Ok (Field :: grade) , crate :: prisma :: score :: perfect :: NAME => Ok (Field :: perfect) , crate :: prisma :: score :: good :: NAME => Ok (Field :: good) , crate :: prisma :: score :: bad :: NAME => Ok (Field :: bad) , crate :: prisma :: score :: miss :: NAME => Ok (Field :: miss) , crate :: prisma :: score :: raw_json :: NAME => Ok (Field :: raw_json) , crate :: prisma :: score :: submission_date :: NAME => Ok (Field :: submission_date) , crate :: prisma :: score :: player_id :: NAME => Ok (Field :: player_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut track_id = None ; let mut track_name = None ; let mut total_points = None ; let mut accuracy = None ; let mut critical = None ; let mut max_combo = None ; let mut grade = None ; let mut perfect = None ; let mut good = None ; let mut bad = None ; let mut miss = None ; let mut raw_json = None ; let mut submission_date = None ; let mut player_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: score :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: track_id => { if track_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: score :: track_id :: NAME)) ; } track_id = Some (map . next_value () ?) ; } Field :: track_name => { if track_name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: score :: track_name :: NAME)) ; } track_name = Some (map . next_value () ?) ; } Field :: total_points => { if total_points . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: score :: total_points :: NAME)) ; } total_points = Some (map . next_value () ?) ; } Field :: accuracy => { if accuracy . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: score :: accuracy :: NAME)) ; } accuracy = Some (map . next_value () ?) ; } Field :: critical => { if critical . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: score :: critical :: NAME)) ; } critical = Some (map . next_value () ?) ; } Field :: max_combo => { if max_combo . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: score :: max_combo :: NAME)) ; } max_combo = Some (map . next_value () ?) ; } Field :: grade => { if grade . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: score :: grade :: NAME)) ; } grade = Some (map . next_value () ?) ; } Field :: perfect => { if perfect . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: score :: perfect :: NAME)) ; } perfect = Some (map . next_value () ?) ; } Field :: good => { if good . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: score :: good :: NAME)) ; } good = Some (map . next_value () ?) ; } Field :: bad => { if bad . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: score :: bad :: NAME)) ; } bad = Some (map . next_value () ?) ; } Field :: miss => { if miss . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: score :: miss :: NAME)) ; } miss = Some (map . next_value () ?) ; } Field :: raw_json => { if raw_json . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: score :: raw_json :: NAME)) ; } raw_json = Some (map . next_value () ?) ; } Field :: submission_date => { if submission_date . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: score :: submission_date :: NAME)) ; } submission_date = Some (map . next_value () ?) ; } Field :: player_id => { if player_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: score :: player_id :: NAME)) ; } player_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: score :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: score :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: score :: id :: NAME)) ? ; let track_id = track_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: score :: track_id :: NAME)) ? ; let track_name = track_name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: score :: track_name :: NAME)) ? ; let total_points = total_points . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: score :: total_points :: NAME)) ? ; let accuracy = accuracy . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: score :: accuracy :: NAME)) ? ; let critical = critical . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: score :: critical :: NAME)) ? ; let max_combo = max_combo . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: score :: max_combo :: NAME)) ? ; let grade = grade . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: score :: grade :: NAME)) ? ; let perfect = perfect . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: score :: perfect :: NAME)) ? ; let good = good . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: score :: good :: NAME)) ? ; let bad = bad . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: score :: bad :: NAME)) ? ; let miss = miss . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: score :: miss :: NAME)) ? ; let raw_json = raw_json . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: score :: raw_json :: NAME)) ? ; let submission_date = submission_date . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: score :: submission_date :: NAME)) ? ; let player_id = player_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: score :: player_id :: NAME)) ? ; Ok (Data { id , track_id , track_name , total_points , accuracy , critical , max_combo , grade , perfect , good , bad , miss , raw_json , submission_date , player_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["Id" , "TrackId" , "TrackName" , "TotalPoints" , "Accuracy" , "Critical" , "MaxCombo" , "Grade" , "Perfect" , "Good" , "Bad" , "Miss" , "RawJson" , "SubmissionDate" , "PlayerId" , "Player"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: score :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; player : $ selection_mode : ident { $ ($ selections : tt) + }) => { player :: Data } ; (@ field_type ; player) => { crate :: prisma :: player :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Score" , available relations are "player")) } ; (@ field_module ; player : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: player :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; player $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: score :: IncludeParam > :: into (crate :: prisma :: score :: player :: Include :: $ selection_mode (crate :: prisma :: player :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; player $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: score :: IncludeParam > :: into (crate :: prisma :: score :: player :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: score :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "Id" } ; (@ field_serde_name ; track_id) => { "TrackId" } ; (@ field_serde_name ; track_name) => { "TrackName" } ; (@ field_serde_name ; total_points) => { "TotalPoints" } ; (@ field_serde_name ; accuracy) => { "Accuracy" } ; (@ field_serde_name ; critical) => { "Critical" } ; (@ field_serde_name ; max_combo) => { "MaxCombo" } ; (@ field_serde_name ; grade) => { "Grade" } ; (@ field_serde_name ; perfect) => { "Perfect" } ; (@ field_serde_name ; good) => { "Good" } ; (@ field_serde_name ; bad) => { "Bad" } ; (@ field_serde_name ; miss) => { "Miss" } ; (@ field_serde_name ; raw_json) => { "RawJson" } ; (@ field_serde_name ; submission_date) => { "SubmissionDate" } ; (@ field_serde_name ; player_id) => { "PlayerId" } ; (@ field_serde_name ; player) => { "Player" } ; }
    pub use _include_score as include;
    pub enum IncludeParam {
        Id(id::Include),
        TrackId(track_id::Include),
        TrackName(track_name::Include),
        TotalPoints(total_points::Include),
        Accuracy(accuracy::Include),
        Critical(critical::Include),
        MaxCombo(max_combo::Include),
        Grade(grade::Include),
        Perfect(perfect::Include),
        Good(good::Include),
        Bad(bad::Include),
        Miss(miss::Include),
        RawJson(raw_json::Include),
        SubmissionDate(submission_date::Include),
        PlayerId(player_id::Include),
        Player(player::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::TrackId(data) => data.to_selection(),
                Self::TrackName(data) => data.to_selection(),
                Self::TotalPoints(data) => data.to_selection(),
                Self::Accuracy(data) => data.to_selection(),
                Self::Critical(data) => data.to_selection(),
                Self::MaxCombo(data) => data.to_selection(),
                Self::Grade(data) => data.to_selection(),
                Self::Perfect(data) => data.to_selection(),
                Self::Good(data) => data.to_selection(),
                Self::Bad(data) => data.to_selection(),
                Self::Miss(data) => data.to_selection(),
                Self::RawJson(data) => data.to_selection(),
                Self::SubmissionDate(data) => data.to_selection(),
                Self::PlayerId(data) => data.to_selection(),
                Self::Player(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules! _partial_unchecked_score { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: score struct $ struct_name { # [serde (rename = "Id")] pub id : i64 , # [serde (rename = "TrackId")] pub track_id : i64 , # [serde (rename = "TrackName")] pub track_name : String , # [serde (rename = "TotalPoints")] pub total_points : i64 , # [serde (rename = "Accuracy")] pub accuracy : f64 , # [serde (rename = "Critical")] pub critical : i64 , # [serde (rename = "MaxCombo")] pub max_combo : i64 , # [serde (rename = "Grade")] pub grade : String , # [serde (rename = "Perfect")] pub perfect : i64 , # [serde (rename = "Good")] pub good : i64 , # [serde (rename = "Bad")] pub bad : i64 , # [serde (rename = "Miss")] pub miss : i64 , # [serde (rename = "RawJson")] pub raw_json : String , # [serde (rename = "SubmissionDate")] pub submission_date : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "PlayerId")] pub player_id : String } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_score as partial_unchecked;
    #[derive(Debug, Clone, ::serde::Serialize, ::serde::Deserialize)]
    pub struct Data {
        #[serde(rename = "Id")]
        pub id: i64,
        #[serde(rename = "TrackId")]
        pub track_id: i64,
        #[serde(rename = "TrackName")]
        pub track_name: String,
        #[serde(rename = "TotalPoints")]
        pub total_points: i64,
        #[serde(rename = "Accuracy")]
        pub accuracy: f64,
        #[serde(rename = "Critical")]
        pub critical: i64,
        #[serde(rename = "MaxCombo")]
        pub max_combo: i64,
        #[serde(rename = "Grade")]
        pub grade: String,
        #[serde(rename = "Perfect")]
        pub perfect: i64,
        #[serde(rename = "Good")]
        pub good: i64,
        #[serde(rename = "Bad")]
        pub bad: i64,
        #[serde(rename = "Miss")]
        pub miss: i64,
        #[serde(rename = "RawJson")]
        pub raw_json: String,
        #[serde(rename = "SubmissionDate")]
        pub submission_date:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "PlayerId")]
        pub player_id: String,
        #[serde(rename = "Player")]
        pub player: Option<Box<super::player::Data>>,
    }
    impl Data {
        pub fn player(
            &self,
        ) -> Result<&super::player::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.player
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(player),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Player(super::player::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Player(args) => {
                    let mut selections = <super::player::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(player::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i64),
        IncrementId(i64),
        DecrementId(i64),
        MultiplyId(i64),
        DivideId(i64),
        SetTrackId(i64),
        IncrementTrackId(i64),
        DecrementTrackId(i64),
        MultiplyTrackId(i64),
        DivideTrackId(i64),
        SetTrackName(String),
        SetTotalPoints(i64),
        IncrementTotalPoints(i64),
        DecrementTotalPoints(i64),
        MultiplyTotalPoints(i64),
        DivideTotalPoints(i64),
        SetAccuracy(f64),
        IncrementAccuracy(f64),
        DecrementAccuracy(f64),
        MultiplyAccuracy(f64),
        DivideAccuracy(f64),
        SetCritical(i64),
        IncrementCritical(i64),
        DecrementCritical(i64),
        MultiplyCritical(i64),
        DivideCritical(i64),
        SetMaxCombo(i64),
        IncrementMaxCombo(i64),
        DecrementMaxCombo(i64),
        MultiplyMaxCombo(i64),
        DivideMaxCombo(i64),
        SetGrade(String),
        SetPerfect(i64),
        IncrementPerfect(i64),
        DecrementPerfect(i64),
        MultiplyPerfect(i64),
        DividePerfect(i64),
        SetGood(i64),
        IncrementGood(i64),
        DecrementGood(i64),
        MultiplyGood(i64),
        DivideGood(i64),
        SetBad(i64),
        IncrementBad(i64),
        DecrementBad(i64),
        MultiplyBad(i64),
        DivideBad(i64),
        SetMiss(i64),
        IncrementMiss(i64),
        DecrementMiss(i64),
        MultiplyMiss(i64),
        DivideMiss(i64),
        SetRawJson(String),
        SetSubmissionDate(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetPlayerId(String),
        ConnectPlayer(super::player::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (id::NAME.to_string(), ::prisma_client_rust::PrismaValue::BigInt(value)),
                SetParam::IncrementId(value) => (id::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("increment".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::DecrementId(value) => (id::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("decrement".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::MultiplyId(value) => (id::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("multiply".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::DivideId(value) => (id::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("divide".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::SetTrackId(value) => (track_id::NAME.to_string(), ::prisma_client_rust::PrismaValue::BigInt(value)),
                SetParam::IncrementTrackId(value) => (track_id::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("increment".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::DecrementTrackId(value) => (track_id::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("decrement".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::MultiplyTrackId(value) => (track_id::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("multiply".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::DivideTrackId(value) => (track_id::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("divide".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::SetTrackName(value) => (track_name::NAME.to_string(), ::prisma_client_rust::PrismaValue::String(value)),
                SetParam::SetTotalPoints(value) => (total_points::NAME.to_string(), ::prisma_client_rust::PrismaValue::BigInt(value)),
                SetParam::IncrementTotalPoints(value) => (total_points::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("increment".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::DecrementTotalPoints(value) => (total_points::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("decrement".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::MultiplyTotalPoints(value) => (total_points::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("multiply".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::DivideTotalPoints(value) => (total_points::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("divide".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::SetAccuracy(value) => (accuracy::NAME.to_string(), ::prisma_client_rust::PrismaValue::Float(<::prisma_client_rust::bigdecimal::BigDecimal as ::prisma_client_rust::bigdecimal::FromPrimitive>::from_f64(value).unwrap().normalized())),
                SetParam::IncrementAccuracy(value) => (accuracy::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("increment".to_string(), ::prisma_client_rust::PrismaValue::Float(<::prisma_client_rust::bigdecimal::BigDecimal as ::prisma_client_rust::bigdecimal::FromPrimitive>::from_f64(value).unwrap().normalized()))])),
                SetParam::DecrementAccuracy(value) => (accuracy::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("decrement".to_string(), ::prisma_client_rust::PrismaValue::Float(<::prisma_client_rust::bigdecimal::BigDecimal as ::prisma_client_rust::bigdecimal::FromPrimitive>::from_f64(value).unwrap().normalized()))])),
                SetParam::MultiplyAccuracy(value) => (accuracy::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("multiply".to_string(), ::prisma_client_rust::PrismaValue::Float(<::prisma_client_rust::bigdecimal::BigDecimal as ::prisma_client_rust::bigdecimal::FromPrimitive>::from_f64(value).unwrap().normalized()))])),
                SetParam::DivideAccuracy(value) => (accuracy::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("divide".to_string(), ::prisma_client_rust::PrismaValue::Float(<::prisma_client_rust::bigdecimal::BigDecimal as ::prisma_client_rust::bigdecimal::FromPrimitive>::from_f64(value).unwrap().normalized()))])),
                SetParam::SetCritical(value) => (critical::NAME.to_string(), ::prisma_client_rust::PrismaValue::BigInt(value)),
                SetParam::IncrementCritical(value) => (critical::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("increment".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::DecrementCritical(value) => (critical::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("decrement".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::MultiplyCritical(value) => (critical::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("multiply".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::DivideCritical(value) => (critical::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("divide".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::SetMaxCombo(value) => (max_combo::NAME.to_string(), ::prisma_client_rust::PrismaValue::BigInt(value)),
                SetParam::IncrementMaxCombo(value) => (max_combo::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("increment".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::DecrementMaxCombo(value) => (max_combo::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("decrement".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::MultiplyMaxCombo(value) => (max_combo::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("multiply".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::DivideMaxCombo(value) => (max_combo::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("divide".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::SetGrade(value) => (grade::NAME.to_string(), ::prisma_client_rust::PrismaValue::String(value)),
                SetParam::SetPerfect(value) => (perfect::NAME.to_string(), ::prisma_client_rust::PrismaValue::BigInt(value)),
                SetParam::IncrementPerfect(value) => (perfect::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("increment".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::DecrementPerfect(value) => (perfect::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("decrement".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::MultiplyPerfect(value) => (perfect::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("multiply".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::DividePerfect(value) => (perfect::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("divide".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::SetGood(value) => (good::NAME.to_string(), ::prisma_client_rust::PrismaValue::BigInt(value)),
                SetParam::IncrementGood(value) => (good::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("increment".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::DecrementGood(value) => (good::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("decrement".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::MultiplyGood(value) => (good::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("multiply".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::DivideGood(value) => (good::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("divide".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::SetBad(value) => (bad::NAME.to_string(), ::prisma_client_rust::PrismaValue::BigInt(value)),
                SetParam::IncrementBad(value) => (bad::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("increment".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::DecrementBad(value) => (bad::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("decrement".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::MultiplyBad(value) => (bad::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("multiply".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::DivideBad(value) => (bad::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("divide".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::SetMiss(value) => (miss::NAME.to_string(), ::prisma_client_rust::PrismaValue::BigInt(value)),
                SetParam::IncrementMiss(value) => (miss::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("increment".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::DecrementMiss(value) => (miss::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("decrement".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::MultiplyMiss(value) => (miss::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("multiply".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::DivideMiss(value) => (miss::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("divide".to_string(), ::prisma_client_rust::PrismaValue::BigInt(value))])),
                SetParam::SetRawJson(value) => (raw_json::NAME.to_string(), ::prisma_client_rust::PrismaValue::String(value)),
                SetParam::SetSubmissionDate(value) => (submission_date::NAME.to_string(), ::prisma_client_rust::PrismaValue::DateTime(value)),
                SetParam::SetPlayerId(value) => (player_id::NAME.to_string(), ::prisma_client_rust::PrismaValue::String(value)),
                SetParam::ConnectPlayer(where_param) => (player::NAME.to_string(), ::prisma_client_rust::PrismaValue::Object(vec![("connect".to_string(), ::prisma_client_rust::PrismaValue::Object([where_param].into_iter().map(Into::<super::player::WhereParam>::into).map(::prisma_client_rust::WhereInput::serialize).map(::prisma_client_rust::SerializedWhereInput::transform_equals).collect()))]))
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i64),
        TrackId(i64),
        TrackName(String),
        TotalPoints(i64),
        Accuracy(f64),
        Critical(i64),
        MaxCombo(i64),
        Grade(String),
        Perfect(i64),
        Good(i64),
        Bad(i64),
        Miss(i64),
        RawJson(String),
        SubmissionDate(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        PlayerId(String),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::TrackId(value) => Self::SetTrackId(value),
                UncheckedSetParam::TrackName(value) => Self::SetTrackName(value),
                UncheckedSetParam::TotalPoints(value) => Self::SetTotalPoints(value),
                UncheckedSetParam::Accuracy(value) => Self::SetAccuracy(value),
                UncheckedSetParam::Critical(value) => Self::SetCritical(value),
                UncheckedSetParam::MaxCombo(value) => Self::SetMaxCombo(value),
                UncheckedSetParam::Grade(value) => Self::SetGrade(value),
                UncheckedSetParam::Perfect(value) => Self::SetPerfect(value),
                UncheckedSetParam::Good(value) => Self::SetGood(value),
                UncheckedSetParam::Bad(value) => Self::SetBad(value),
                UncheckedSetParam::Miss(value) => Self::SetMiss(value),
                UncheckedSetParam::RawJson(value) => Self::SetRawJson(value),
                UncheckedSetParam::SubmissionDate(value) => Self::SetSubmissionDate(value),
                UncheckedSetParam::PlayerId(value) => Self::SetPlayerId(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        TrackId(::prisma_client_rust::Direction),
        TrackName(::prisma_client_rust::Direction),
        TotalPoints(::prisma_client_rust::Direction),
        Accuracy(::prisma_client_rust::Direction),
        Critical(::prisma_client_rust::Direction),
        MaxCombo(::prisma_client_rust::Direction),
        Grade(::prisma_client_rust::Direction),
        Perfect(::prisma_client_rust::Direction),
        Good(::prisma_client_rust::Direction),
        Bad(::prisma_client_rust::Direction),
        Miss(::prisma_client_rust::Direction),
        RawJson(::prisma_client_rust::Direction),
        SubmissionDate(::prisma_client_rust::Direction),
        PlayerId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::TrackId(direction) => (
                    track_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::TrackName(direction) => (
                    track_name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::TotalPoints(direction) => (
                    total_points::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Accuracy(direction) => (
                    accuracy::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Critical(direction) => (
                    critical::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::MaxCombo(direction) => (
                    max_combo::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Grade(direction) => (
                    grade::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Perfect(direction) => (
                    perfect::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Good(direction) => (
                    good::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Bad(direction) => (
                    bad::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Miss(direction) => (
                    miss::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::RawJson(direction) => (
                    raw_json::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::SubmissionDate(direction) => (
                    submission_date::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::PlayerId(direction) => (
                    player_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::BigIntFilter),
        TrackId(_prisma::read_filters::BigIntFilter),
        TrackName(_prisma::read_filters::StringFilter),
        TotalPoints(_prisma::read_filters::BigIntFilter),
        Accuracy(_prisma::read_filters::FloatFilter),
        Critical(_prisma::read_filters::BigIntFilter),
        MaxCombo(_prisma::read_filters::BigIntFilter),
        Grade(_prisma::read_filters::StringFilter),
        Perfect(_prisma::read_filters::BigIntFilter),
        Good(_prisma::read_filters::BigIntFilter),
        Bad(_prisma::read_filters::BigIntFilter),
        Miss(_prisma::read_filters::BigIntFilter),
        RawJson(_prisma::read_filters::StringFilter),
        SubmissionDate(_prisma::read_filters::DateTimeFilter),
        PlayerId(_prisma::read_filters::StringFilter),
        PlayerIs(Vec<super::player::WhereParam>),
        PlayerIsNot(Vec<super::player::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::TrackId(value) => (track_id::NAME, value.into()),
                Self::TrackName(value) => (track_name::NAME, value.into()),
                Self::TotalPoints(value) => (total_points::NAME, value.into()),
                Self::Accuracy(value) => (accuracy::NAME, value.into()),
                Self::Critical(value) => (critical::NAME, value.into()),
                Self::MaxCombo(value) => (max_combo::NAME, value.into()),
                Self::Grade(value) => (grade::NAME, value.into()),
                Self::Perfect(value) => (perfect::NAME, value.into()),
                Self::Good(value) => (good::NAME, value.into()),
                Self::Bad(value) => (bad::NAME, value.into()),
                Self::Miss(value) => (miss::NAME, value.into()),
                Self::RawJson(value) => (raw_json::NAME, value.into()),
                Self::SubmissionDate(value) => (submission_date::NAME, value.into()),
                Self::PlayerId(value) => (player_id::NAME, value.into()),
                Self::PlayerIs(where_params) => (
                    player::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::PlayerIsNot(where_params) => (
                    player::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i64),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::BigIntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(track_id::NAME),
                ::prisma_client_rust::sel(track_name::NAME),
                ::prisma_client_rust::sel(total_points::NAME),
                ::prisma_client_rust::sel(accuracy::NAME),
                ::prisma_client_rust::sel(critical::NAME),
                ::prisma_client_rust::sel(max_combo::NAME),
                ::prisma_client_rust::sel(grade::NAME),
                ::prisma_client_rust::sel(perfect::NAME),
                ::prisma_client_rust::sel(good::NAME),
                ::prisma_client_rust::sel(bad::NAME),
                ::prisma_client_rust::sel(miss::NAME),
                ::prisma_client_rust::sel(raw_json::NAME),
                ::prisma_client_rust::sel(submission_date::NAME),
                ::prisma_client_rust::sel(player_id::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            track_id: i64,
            track_name: String,
            total_points: i64,
            accuracy: f64,
            critical: i64,
            max_combo: i64,
            grade: String,
            perfect: i64,
            good: i64,
            bad: i64,
            miss: i64,
            raw_json: String,
            submission_date: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
            player: super::player::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                track_id::set(track_id),
                track_name::set(track_name),
                total_points::set(total_points),
                accuracy::set(accuracy),
                critical::set(critical),
                max_combo::set(max_combo),
                grade::set(grade),
                perfect::set(perfect),
                good::set(good),
                bad::set(bad),
                miss::set(miss),
                raw_json::set(raw_json),
                submission_date::set(submission_date),
                player::connect(player),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            track_id: i64,
            track_name: String,
            total_points: i64,
            accuracy: f64,
            critical: i64,
            max_combo: i64,
            grade: String,
            perfect: i64,
            good: i64,
            bad: i64,
            miss: i64,
            raw_json: String,
            submission_date: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
            player_id: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                track_id::set(track_id),
                track_name::set(track_name),
                total_points::set(total_points),
                accuracy::set(accuracy),
                critical::set(critical),
                max_combo::set(max_combo),
                grade::set(grade),
                perfect::set(perfect),
                good::set(good),
                bad::set(bad),
                miss::set(miss),
                raw_json::set(raw_json),
                submission_date::set(submission_date),
                player_id::set(player_id),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (
                track_id,
                track_name,
                total_points,
                accuracy,
                critical,
                max_combo,
                grade,
                perfect,
                good,
                bad,
                miss,
                raw_json,
                submission_date,
                player,
                mut _params,
            ): (
                i64,
                String,
                i64,
                f64,
                i64,
                i64,
                String,
                i64,
                i64,
                i64,
                i64,
                String,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                super::player::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                track_id::set(track_id),
                track_name::set(track_name),
                total_points::set(total_points),
                accuracy::set(accuracy),
                critical::set(critical),
                max_combo::set(max_combo),
                grade::set(grade),
                perfect::set(perfect),
                good::set(good),
                bad::set(bad),
                miss::set(miss),
                raw_json::set(raw_json),
                submission_date::set(submission_date),
                player::connect(player),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod setting {
    use super::*;
    pub const NAME: &str = "Setting";
    pub mod id {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
        };
        pub const NAME: &str = "Id";
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i64) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BigIntFilter, Id, {
            fn in_vec(_: Vec<i64>) -> InVec;
            fn not_in_vec(_: Vec<i64>) -> NotInVec;
            fn lt(_: i64) -> Lt;
            fn lte(_: i64) -> Lte;
            fn gt(_: i64) -> Gt;
            fn gte(_: i64) -> Gte;
            fn not(_: i64) -> Not;
        });
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod key_code_1 {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "KeyCode1";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetKeyCode1(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::KeyCode1(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::KeyCode1(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::KeyCode1(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            KeyCode1,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementKeyCode1(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementKeyCode1(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyKeyCode1(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideKeyCode1(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::KeyCode1(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::KeyCode1(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod key_code_2 {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "KeyCode2";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetKeyCode2(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::KeyCode2(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::KeyCode2(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::KeyCode2(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            KeyCode2,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementKeyCode2(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementKeyCode2(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyKeyCode2(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideKeyCode2(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::KeyCode2(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::KeyCode2(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod key_code_3 {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "KeyCode3";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetKeyCode3(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::KeyCode3(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::KeyCode3(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::KeyCode3(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            KeyCode3,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementKeyCode3(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementKeyCode3(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyKeyCode3(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideKeyCode3(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::KeyCode3(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::KeyCode3(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod key_code_4 {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "KeyCode4";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetKeyCode4(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::KeyCode4(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::KeyCode4(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::KeyCode4(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            KeyCode4,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementKeyCode4(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementKeyCode4(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyKeyCode4(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideKeyCode4(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::KeyCode4(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::KeyCode4(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod master_volume {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "MasterVolume";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetMasterVolume(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::MasterVolume(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::MasterVolume(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::MasterVolume(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            MasterVolume,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementMasterVolume(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementMasterVolume(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyMasterVolume(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideMasterVolume(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::MasterVolume(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::MasterVolume(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod music_volume {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "MusicVolume";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetMusicVolume(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::MusicVolume(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::MusicVolume(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::MusicVolume(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            MusicVolume,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementMusicVolume(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementMusicVolume(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyMusicVolume(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideMusicVolume(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::MusicVolume(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::MusicVolume(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod sound_effect_volume {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "SoundEffectVolume";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetSoundEffectVolume(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::SoundEffectVolume(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::SoundEffectVolume(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::SoundEffectVolume(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            SoundEffectVolume,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementSoundEffectVolume(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementSoundEffectVolume(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplySoundEffectVolume(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideSoundEffectVolume(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::SoundEffectVolume(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::SoundEffectVolume(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod offset {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "Offset";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetOffset(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Offset(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Offset(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::Offset(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Offset, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementOffset(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementOffset(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyOffset(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideOffset(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Offset(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Offset(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod frame_rate {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "FrameRate";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetFrameRate(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::FrameRate(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::FrameRate(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::FrameRate(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            FrameRate,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementFrameRate(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementFrameRate(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyFrameRate(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideFrameRate(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::FrameRate(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::FrameRate(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod player_id {
        use super::super::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
        };
        pub const NAME: &str = "PlayerId";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetPlayerId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::PlayerId(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::PlayerId(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::PlayerIdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            PlayerId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::PlayerId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::PlayerId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod player {
        use super::super::*;
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "Player";
        pub struct Fetch(pub player::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<player::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Player(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(player::UniqueArgs::new())
        }
        pub struct Connect(player::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectPlayer(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: player::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<player::WhereParam>) -> WhereParam {
            WhereParam::PlayerIs(value)
        }
        pub fn is_not(value: Vec<player::WhereParam>) -> WhereParam {
            WhereParam::PlayerIsNot(value)
        }
        pub enum Include {
            Select(Vec<player::SelectParam>),
            Include(Vec<player::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Player(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <player::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <player::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("Player", None, [], selections)
            }
            pub fn select(nested_selections: Vec<player::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<player::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<player::SelectParam>),
            Include(Vec<player::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Player(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <player::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("Player", None, [], selections)
            }
            pub fn select(nested_selections: Vec<player::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<player::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(
        key_code_1: i32,
        key_code_2: i32,
        key_code_3: i32,
        key_code_4: i32,
        master_volume: i32,
        music_volume: i32,
        sound_effect_volume: i32,
        offset: i32,
        frame_rate: i32,
        player: super::player::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        i32,
        i32,
        i32,
        i32,
        i32,
        i32,
        i32,
        i32,
        i32,
        super::player::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (
            key_code_1,
            key_code_2,
            key_code_3,
            key_code_4,
            master_volume,
            music_volume,
            sound_effect_volume,
            offset,
            frame_rate,
            player,
            _params,
        )
    }
    pub fn create_unchecked(
        key_code_1: i32,
        key_code_2: i32,
        key_code_3: i32,
        key_code_4: i32,
        master_volume: i32,
        music_volume: i32,
        sound_effect_volume: i32,
        offset: i32,
        frame_rate: i32,
        player_id: String,
        _params: Vec<SetParam>,
    ) -> (
        i32,
        i32,
        i32,
        i32,
        i32,
        i32,
        i32,
        i32,
        i32,
        String,
        Vec<SetParam>,
    ) {
        (
            key_code_1,
            key_code_2,
            key_code_3,
            key_code_4,
            master_volume,
            music_volume,
            sound_effect_volume,
            offset,
            frame_rate,
            player_id,
            _params,
        )
    }
    #[macro_export]
    macro_rules! _select_setting { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: setting :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: setting :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: setting :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: setting :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: setting :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: setting :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , key_code_1 , key_code_2 , key_code_3 , key_code_4 , master_volume , music_volume , sound_effect_volume , offset , frame_rate , player_id , player } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: setting :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: setting :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: setting :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: setting :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: setting :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: setting :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["Id" , "KeyCode1" , "KeyCode2" , "KeyCode3" , "KeyCode4" , "MasterVolume" , "MusicVolume" , "SoundEffectVolume" , "Offset" , "FrameRate" , "PlayerId" , "Player"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: setting :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i64 } ; (@ field_type ; key_code_1) => { i32 } ; (@ field_type ; key_code_2) => { i32 } ; (@ field_type ; key_code_3) => { i32 } ; (@ field_type ; key_code_4) => { i32 } ; (@ field_type ; master_volume) => { i32 } ; (@ field_type ; music_volume) => { i32 } ; (@ field_type ; sound_effect_volume) => { i32 } ; (@ field_type ; offset) => { i32 } ; (@ field_type ; frame_rate) => { i32 } ; (@ field_type ; player_id) => { String } ; (@ field_type ; player : $ selection_mode : ident { $ ($ selections : tt) + }) => { player :: Data } ; (@ field_type ; player) => { crate :: prisma :: player :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Setting" , available relations are "id, key_code_1, key_code_2, key_code_3, key_code_4, master_volume, music_volume, sound_effect_volume, offset, frame_rate, player_id, player")) } ; (@ field_module ; player : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: player :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: setting :: SelectParam > :: into (crate :: prisma :: setting :: id :: Select) } ; (@ selection_field_to_selection_param ; key_code_1) => { Into :: < crate :: prisma :: setting :: SelectParam > :: into (crate :: prisma :: setting :: key_code_1 :: Select) } ; (@ selection_field_to_selection_param ; key_code_2) => { Into :: < crate :: prisma :: setting :: SelectParam > :: into (crate :: prisma :: setting :: key_code_2 :: Select) } ; (@ selection_field_to_selection_param ; key_code_3) => { Into :: < crate :: prisma :: setting :: SelectParam > :: into (crate :: prisma :: setting :: key_code_3 :: Select) } ; (@ selection_field_to_selection_param ; key_code_4) => { Into :: < crate :: prisma :: setting :: SelectParam > :: into (crate :: prisma :: setting :: key_code_4 :: Select) } ; (@ selection_field_to_selection_param ; master_volume) => { Into :: < crate :: prisma :: setting :: SelectParam > :: into (crate :: prisma :: setting :: master_volume :: Select) } ; (@ selection_field_to_selection_param ; music_volume) => { Into :: < crate :: prisma :: setting :: SelectParam > :: into (crate :: prisma :: setting :: music_volume :: Select) } ; (@ selection_field_to_selection_param ; sound_effect_volume) => { Into :: < crate :: prisma :: setting :: SelectParam > :: into (crate :: prisma :: setting :: sound_effect_volume :: Select) } ; (@ selection_field_to_selection_param ; offset) => { Into :: < crate :: prisma :: setting :: SelectParam > :: into (crate :: prisma :: setting :: offset :: Select) } ; (@ selection_field_to_selection_param ; frame_rate) => { Into :: < crate :: prisma :: setting :: SelectParam > :: into (crate :: prisma :: setting :: frame_rate :: Select) } ; (@ selection_field_to_selection_param ; player_id) => { Into :: < crate :: prisma :: setting :: SelectParam > :: into (crate :: prisma :: setting :: player_id :: Select) } ; (@ selection_field_to_selection_param ; player $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: setting :: SelectParam > :: into (crate :: prisma :: setting :: player :: Select :: $ selection_mode (crate :: prisma :: player :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; player $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: setting :: SelectParam > :: into (crate :: prisma :: setting :: player :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: setting :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "Id" } ; (@ field_serde_name ; key_code_1) => { "KeyCode1" } ; (@ field_serde_name ; key_code_2) => { "KeyCode2" } ; (@ field_serde_name ; key_code_3) => { "KeyCode3" } ; (@ field_serde_name ; key_code_4) => { "KeyCode4" } ; (@ field_serde_name ; master_volume) => { "MasterVolume" } ; (@ field_serde_name ; music_volume) => { "MusicVolume" } ; (@ field_serde_name ; sound_effect_volume) => { "SoundEffectVolume" } ; (@ field_serde_name ; offset) => { "Offset" } ; (@ field_serde_name ; frame_rate) => { "FrameRate" } ; (@ field_serde_name ; player_id) => { "PlayerId" } ; (@ field_serde_name ; player) => { "Player" } ; }
    pub use _select_setting as select;
    pub enum SelectParam {
        Id(id::Select),
        KeyCode1(key_code_1::Select),
        KeyCode2(key_code_2::Select),
        KeyCode3(key_code_3::Select),
        KeyCode4(key_code_4::Select),
        MasterVolume(master_volume::Select),
        MusicVolume(music_volume::Select),
        SoundEffectVolume(sound_effect_volume::Select),
        Offset(offset::Select),
        FrameRate(frame_rate::Select),
        PlayerId(player_id::Select),
        Player(player::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::KeyCode1(data) => data.to_selection(),
                Self::KeyCode2(data) => data.to_selection(),
                Self::KeyCode3(data) => data.to_selection(),
                Self::KeyCode4(data) => data.to_selection(),
                Self::MasterVolume(data) => data.to_selection(),
                Self::MusicVolume(data) => data.to_selection(),
                Self::SoundEffectVolume(data) => data.to_selection(),
                Self::Offset(data) => data.to_selection(),
                Self::FrameRate(data) => data.to_selection(),
                Self::PlayerId(data) => data.to_selection(),
                Self::Player(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules! _include_setting { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: setting :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: setting :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: setting :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: setting :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: setting :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: setting :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: setting :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: setting :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { player } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i64 , pub key_code_1 : i32 , pub key_code_2 : i32 , pub key_code_3 : i32 , pub key_code_4 : i32 , pub master_volume : i32 , pub music_volume : i32 , pub sound_effect_volume : i32 , pub offset : i32 , pub frame_rate : i32 , pub player_id : String , $ (pub $ field : crate :: prisma :: setting :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (key_code_1) , stringify ! (key_code_2) , stringify ! (key_code_3) , stringify ! (key_code_4) , stringify ! (master_volume) , stringify ! (music_volume) , stringify ! (sound_effect_volume) , stringify ! (offset) , stringify ! (frame_rate) , stringify ! (player_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: setting :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: setting :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: setting :: key_code_1 :: NAME , & self . key_code_1) ? ; state . serialize_field (crate :: prisma :: setting :: key_code_2 :: NAME , & self . key_code_2) ? ; state . serialize_field (crate :: prisma :: setting :: key_code_3 :: NAME , & self . key_code_3) ? ; state . serialize_field (crate :: prisma :: setting :: key_code_4 :: NAME , & self . key_code_4) ? ; state . serialize_field (crate :: prisma :: setting :: master_volume :: NAME , & self . master_volume) ? ; state . serialize_field (crate :: prisma :: setting :: music_volume :: NAME , & self . music_volume) ? ; state . serialize_field (crate :: prisma :: setting :: sound_effect_volume :: NAME , & self . sound_effect_volume) ? ; state . serialize_field (crate :: prisma :: setting :: offset :: NAME , & self . offset) ? ; state . serialize_field (crate :: prisma :: setting :: frame_rate :: NAME , & self . frame_rate) ? ; state . serialize_field (crate :: prisma :: setting :: player_id :: NAME , & self . player_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , key_code_1 , key_code_2 , key_code_3 , key_code_4 , master_volume , music_volume , sound_effect_volume , offset , frame_rate , player_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: setting :: $ field :: NAME) , + , crate :: prisma :: setting :: id :: NAME , crate :: prisma :: setting :: key_code_1 :: NAME , crate :: prisma :: setting :: key_code_2 :: NAME , crate :: prisma :: setting :: key_code_3 :: NAME , crate :: prisma :: setting :: key_code_4 :: NAME , crate :: prisma :: setting :: master_volume :: NAME , crate :: prisma :: setting :: music_volume :: NAME , crate :: prisma :: setting :: sound_effect_volume :: NAME , crate :: prisma :: setting :: offset :: NAME , crate :: prisma :: setting :: frame_rate :: NAME , crate :: prisma :: setting :: player_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: setting :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: setting :: id :: NAME => Ok (Field :: id) , crate :: prisma :: setting :: key_code_1 :: NAME => Ok (Field :: key_code_1) , crate :: prisma :: setting :: key_code_2 :: NAME => Ok (Field :: key_code_2) , crate :: prisma :: setting :: key_code_3 :: NAME => Ok (Field :: key_code_3) , crate :: prisma :: setting :: key_code_4 :: NAME => Ok (Field :: key_code_4) , crate :: prisma :: setting :: master_volume :: NAME => Ok (Field :: master_volume) , crate :: prisma :: setting :: music_volume :: NAME => Ok (Field :: music_volume) , crate :: prisma :: setting :: sound_effect_volume :: NAME => Ok (Field :: sound_effect_volume) , crate :: prisma :: setting :: offset :: NAME => Ok (Field :: offset) , crate :: prisma :: setting :: frame_rate :: NAME => Ok (Field :: frame_rate) , crate :: prisma :: setting :: player_id :: NAME => Ok (Field :: player_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut key_code_1 = None ; let mut key_code_2 = None ; let mut key_code_3 = None ; let mut key_code_4 = None ; let mut master_volume = None ; let mut music_volume = None ; let mut sound_effect_volume = None ; let mut offset = None ; let mut frame_rate = None ; let mut player_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: setting :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: key_code_1 => { if key_code_1 . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: setting :: key_code_1 :: NAME)) ; } key_code_1 = Some (map . next_value () ?) ; } Field :: key_code_2 => { if key_code_2 . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: setting :: key_code_2 :: NAME)) ; } key_code_2 = Some (map . next_value () ?) ; } Field :: key_code_3 => { if key_code_3 . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: setting :: key_code_3 :: NAME)) ; } key_code_3 = Some (map . next_value () ?) ; } Field :: key_code_4 => { if key_code_4 . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: setting :: key_code_4 :: NAME)) ; } key_code_4 = Some (map . next_value () ?) ; } Field :: master_volume => { if master_volume . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: setting :: master_volume :: NAME)) ; } master_volume = Some (map . next_value () ?) ; } Field :: music_volume => { if music_volume . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: setting :: music_volume :: NAME)) ; } music_volume = Some (map . next_value () ?) ; } Field :: sound_effect_volume => { if sound_effect_volume . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: setting :: sound_effect_volume :: NAME)) ; } sound_effect_volume = Some (map . next_value () ?) ; } Field :: offset => { if offset . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: setting :: offset :: NAME)) ; } offset = Some (map . next_value () ?) ; } Field :: frame_rate => { if frame_rate . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: setting :: frame_rate :: NAME)) ; } frame_rate = Some (map . next_value () ?) ; } Field :: player_id => { if player_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: setting :: player_id :: NAME)) ; } player_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: setting :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: setting :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: setting :: id :: NAME)) ? ; let key_code_1 = key_code_1 . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: setting :: key_code_1 :: NAME)) ? ; let key_code_2 = key_code_2 . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: setting :: key_code_2 :: NAME)) ? ; let key_code_3 = key_code_3 . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: setting :: key_code_3 :: NAME)) ? ; let key_code_4 = key_code_4 . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: setting :: key_code_4 :: NAME)) ? ; let master_volume = master_volume . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: setting :: master_volume :: NAME)) ? ; let music_volume = music_volume . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: setting :: music_volume :: NAME)) ? ; let sound_effect_volume = sound_effect_volume . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: setting :: sound_effect_volume :: NAME)) ? ; let offset = offset . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: setting :: offset :: NAME)) ? ; let frame_rate = frame_rate . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: setting :: frame_rate :: NAME)) ? ; let player_id = player_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: setting :: player_id :: NAME)) ? ; Ok (Data { id , key_code_1 , key_code_2 , key_code_3 , key_code_4 , master_volume , music_volume , sound_effect_volume , offset , frame_rate , player_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["Id" , "KeyCode1" , "KeyCode2" , "KeyCode3" , "KeyCode4" , "MasterVolume" , "MusicVolume" , "SoundEffectVolume" , "Offset" , "FrameRate" , "PlayerId" , "Player"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: setting :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; player : $ selection_mode : ident { $ ($ selections : tt) + }) => { player :: Data } ; (@ field_type ; player) => { crate :: prisma :: player :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Setting" , available relations are "player")) } ; (@ field_module ; player : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: player :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; player $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: setting :: IncludeParam > :: into (crate :: prisma :: setting :: player :: Include :: $ selection_mode (crate :: prisma :: player :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; player $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: setting :: IncludeParam > :: into (crate :: prisma :: setting :: player :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: setting :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "Id" } ; (@ field_serde_name ; key_code_1) => { "KeyCode1" } ; (@ field_serde_name ; key_code_2) => { "KeyCode2" } ; (@ field_serde_name ; key_code_3) => { "KeyCode3" } ; (@ field_serde_name ; key_code_4) => { "KeyCode4" } ; (@ field_serde_name ; master_volume) => { "MasterVolume" } ; (@ field_serde_name ; music_volume) => { "MusicVolume" } ; (@ field_serde_name ; sound_effect_volume) => { "SoundEffectVolume" } ; (@ field_serde_name ; offset) => { "Offset" } ; (@ field_serde_name ; frame_rate) => { "FrameRate" } ; (@ field_serde_name ; player_id) => { "PlayerId" } ; (@ field_serde_name ; player) => { "Player" } ; }
    pub use _include_setting as include;
    pub enum IncludeParam {
        Id(id::Include),
        KeyCode1(key_code_1::Include),
        KeyCode2(key_code_2::Include),
        KeyCode3(key_code_3::Include),
        KeyCode4(key_code_4::Include),
        MasterVolume(master_volume::Include),
        MusicVolume(music_volume::Include),
        SoundEffectVolume(sound_effect_volume::Include),
        Offset(offset::Include),
        FrameRate(frame_rate::Include),
        PlayerId(player_id::Include),
        Player(player::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::KeyCode1(data) => data.to_selection(),
                Self::KeyCode2(data) => data.to_selection(),
                Self::KeyCode3(data) => data.to_selection(),
                Self::KeyCode4(data) => data.to_selection(),
                Self::MasterVolume(data) => data.to_selection(),
                Self::MusicVolume(data) => data.to_selection(),
                Self::SoundEffectVolume(data) => data.to_selection(),
                Self::Offset(data) => data.to_selection(),
                Self::FrameRate(data) => data.to_selection(),
                Self::PlayerId(data) => data.to_selection(),
                Self::Player(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules! _partial_unchecked_setting { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: setting struct $ struct_name { # [serde (rename = "Id")] pub id : i64 , # [serde (rename = "KeyCode1")] pub key_code_1 : i32 , # [serde (rename = "KeyCode2")] pub key_code_2 : i32 , # [serde (rename = "KeyCode3")] pub key_code_3 : i32 , # [serde (rename = "KeyCode4")] pub key_code_4 : i32 , # [serde (rename = "MasterVolume")] pub master_volume : i32 , # [serde (rename = "MusicVolume")] pub music_volume : i32 , # [serde (rename = "SoundEffectVolume")] pub sound_effect_volume : i32 , # [serde (rename = "Offset")] pub offset : i32 , # [serde (rename = "FrameRate")] pub frame_rate : i32 , # [serde (rename = "PlayerId")] pub player_id : String } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_setting as partial_unchecked;
    #[derive(Debug, Clone, ::serde::Serialize, ::serde::Deserialize)]
    pub struct Data {
        #[serde(rename = "Id")]
        pub id: i64,
        #[serde(rename = "KeyCode1")]
        pub key_code_1: i32,
        #[serde(rename = "KeyCode2")]
        pub key_code_2: i32,
        #[serde(rename = "KeyCode3")]
        pub key_code_3: i32,
        #[serde(rename = "KeyCode4")]
        pub key_code_4: i32,
        #[serde(rename = "MasterVolume")]
        pub master_volume: i32,
        #[serde(rename = "MusicVolume")]
        pub music_volume: i32,
        #[serde(rename = "SoundEffectVolume")]
        pub sound_effect_volume: i32,
        #[serde(rename = "Offset")]
        pub offset: i32,
        #[serde(rename = "FrameRate")]
        pub frame_rate: i32,
        #[serde(rename = "PlayerId")]
        pub player_id: String,
        #[serde(rename = "Player")]
        pub player: Option<Box<super::player::Data>>,
    }
    impl Data {
        pub fn player(
            &self,
        ) -> Result<&super::player::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.player
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(player),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Player(super::player::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Player(args) => {
                    let mut selections = <super::player::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(player::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i64),
        IncrementId(i64),
        DecrementId(i64),
        MultiplyId(i64),
        DivideId(i64),
        SetKeyCode1(i32),
        IncrementKeyCode1(i32),
        DecrementKeyCode1(i32),
        MultiplyKeyCode1(i32),
        DivideKeyCode1(i32),
        SetKeyCode2(i32),
        IncrementKeyCode2(i32),
        DecrementKeyCode2(i32),
        MultiplyKeyCode2(i32),
        DivideKeyCode2(i32),
        SetKeyCode3(i32),
        IncrementKeyCode3(i32),
        DecrementKeyCode3(i32),
        MultiplyKeyCode3(i32),
        DivideKeyCode3(i32),
        SetKeyCode4(i32),
        IncrementKeyCode4(i32),
        DecrementKeyCode4(i32),
        MultiplyKeyCode4(i32),
        DivideKeyCode4(i32),
        SetMasterVolume(i32),
        IncrementMasterVolume(i32),
        DecrementMasterVolume(i32),
        MultiplyMasterVolume(i32),
        DivideMasterVolume(i32),
        SetMusicVolume(i32),
        IncrementMusicVolume(i32),
        DecrementMusicVolume(i32),
        MultiplyMusicVolume(i32),
        DivideMusicVolume(i32),
        SetSoundEffectVolume(i32),
        IncrementSoundEffectVolume(i32),
        DecrementSoundEffectVolume(i32),
        MultiplySoundEffectVolume(i32),
        DivideSoundEffectVolume(i32),
        SetOffset(i32),
        IncrementOffset(i32),
        DecrementOffset(i32),
        MultiplyOffset(i32),
        DivideOffset(i32),
        SetFrameRate(i32),
        IncrementFrameRate(i32),
        DecrementFrameRate(i32),
        MultiplyFrameRate(i32),
        DivideFrameRate(i32),
        SetPlayerId(String),
        ConnectPlayer(super::player::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetKeyCode1(value) => (
                    key_code_1::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementKeyCode1(value) => (
                    key_code_1::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementKeyCode1(value) => (
                    key_code_1::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyKeyCode1(value) => (
                    key_code_1::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideKeyCode1(value) => (
                    key_code_1::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetKeyCode2(value) => (
                    key_code_2::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementKeyCode2(value) => (
                    key_code_2::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementKeyCode2(value) => (
                    key_code_2::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyKeyCode2(value) => (
                    key_code_2::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideKeyCode2(value) => (
                    key_code_2::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetKeyCode3(value) => (
                    key_code_3::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementKeyCode3(value) => (
                    key_code_3::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementKeyCode3(value) => (
                    key_code_3::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyKeyCode3(value) => (
                    key_code_3::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideKeyCode3(value) => (
                    key_code_3::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetKeyCode4(value) => (
                    key_code_4::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementKeyCode4(value) => (
                    key_code_4::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementKeyCode4(value) => (
                    key_code_4::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyKeyCode4(value) => (
                    key_code_4::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideKeyCode4(value) => (
                    key_code_4::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetMasterVolume(value) => (
                    master_volume::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementMasterVolume(value) => (
                    master_volume::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementMasterVolume(value) => (
                    master_volume::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyMasterVolume(value) => (
                    master_volume::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideMasterVolume(value) => (
                    master_volume::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetMusicVolume(value) => (
                    music_volume::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementMusicVolume(value) => (
                    music_volume::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementMusicVolume(value) => (
                    music_volume::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyMusicVolume(value) => (
                    music_volume::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideMusicVolume(value) => (
                    music_volume::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetSoundEffectVolume(value) => (
                    sound_effect_volume::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementSoundEffectVolume(value) => (
                    sound_effect_volume::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementSoundEffectVolume(value) => (
                    sound_effect_volume::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplySoundEffectVolume(value) => (
                    sound_effect_volume::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideSoundEffectVolume(value) => (
                    sound_effect_volume::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetOffset(value) => (
                    offset::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementOffset(value) => (
                    offset::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementOffset(value) => (
                    offset::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyOffset(value) => (
                    offset::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideOffset(value) => (
                    offset::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetFrameRate(value) => (
                    frame_rate::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementFrameRate(value) => (
                    frame_rate::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementFrameRate(value) => (
                    frame_rate::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyFrameRate(value) => (
                    frame_rate::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideFrameRate(value) => (
                    frame_rate::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetPlayerId(value) => (
                    player_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectPlayer(where_param) => (
                    player::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::player::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i64),
        KeyCode1(i32),
        KeyCode2(i32),
        KeyCode3(i32),
        KeyCode4(i32),
        MasterVolume(i32),
        MusicVolume(i32),
        SoundEffectVolume(i32),
        Offset(i32),
        FrameRate(i32),
        PlayerId(String),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::KeyCode1(value) => Self::SetKeyCode1(value),
                UncheckedSetParam::KeyCode2(value) => Self::SetKeyCode2(value),
                UncheckedSetParam::KeyCode3(value) => Self::SetKeyCode3(value),
                UncheckedSetParam::KeyCode4(value) => Self::SetKeyCode4(value),
                UncheckedSetParam::MasterVolume(value) => Self::SetMasterVolume(value),
                UncheckedSetParam::MusicVolume(value) => Self::SetMusicVolume(value),
                UncheckedSetParam::SoundEffectVolume(value) => Self::SetSoundEffectVolume(value),
                UncheckedSetParam::Offset(value) => Self::SetOffset(value),
                UncheckedSetParam::FrameRate(value) => Self::SetFrameRate(value),
                UncheckedSetParam::PlayerId(value) => Self::SetPlayerId(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        KeyCode1(::prisma_client_rust::Direction),
        KeyCode2(::prisma_client_rust::Direction),
        KeyCode3(::prisma_client_rust::Direction),
        KeyCode4(::prisma_client_rust::Direction),
        MasterVolume(::prisma_client_rust::Direction),
        MusicVolume(::prisma_client_rust::Direction),
        SoundEffectVolume(::prisma_client_rust::Direction),
        Offset(::prisma_client_rust::Direction),
        FrameRate(::prisma_client_rust::Direction),
        PlayerId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::KeyCode1(direction) => (
                    key_code_1::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::KeyCode2(direction) => (
                    key_code_2::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::KeyCode3(direction) => (
                    key_code_3::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::KeyCode4(direction) => (
                    key_code_4::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::MasterVolume(direction) => (
                    master_volume::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::MusicVolume(direction) => (
                    music_volume::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::SoundEffectVolume(direction) => (
                    sound_effect_volume::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Offset(direction) => (
                    offset::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::FrameRate(direction) => (
                    frame_rate::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::PlayerId(direction) => (
                    player_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::BigIntFilter),
        KeyCode1(_prisma::read_filters::IntFilter),
        KeyCode2(_prisma::read_filters::IntFilter),
        KeyCode3(_prisma::read_filters::IntFilter),
        KeyCode4(_prisma::read_filters::IntFilter),
        MasterVolume(_prisma::read_filters::IntFilter),
        MusicVolume(_prisma::read_filters::IntFilter),
        SoundEffectVolume(_prisma::read_filters::IntFilter),
        Offset(_prisma::read_filters::IntFilter),
        FrameRate(_prisma::read_filters::IntFilter),
        PlayerId(_prisma::read_filters::StringFilter),
        PlayerIs(Vec<super::player::WhereParam>),
        PlayerIsNot(Vec<super::player::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::KeyCode1(value) => (key_code_1::NAME, value.into()),
                Self::KeyCode2(value) => (key_code_2::NAME, value.into()),
                Self::KeyCode3(value) => (key_code_3::NAME, value.into()),
                Self::KeyCode4(value) => (key_code_4::NAME, value.into()),
                Self::MasterVolume(value) => (master_volume::NAME, value.into()),
                Self::MusicVolume(value) => (music_volume::NAME, value.into()),
                Self::SoundEffectVolume(value) => (sound_effect_volume::NAME, value.into()),
                Self::Offset(value) => (offset::NAME, value.into()),
                Self::FrameRate(value) => (frame_rate::NAME, value.into()),
                Self::PlayerId(value) => (player_id::NAME, value.into()),
                Self::PlayerIs(where_params) => (
                    player::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::PlayerIsNot(where_params) => (
                    player::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        PlayerIdEquals(String),
        IdEquals(i64),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::PlayerIdEquals(value) => {
                    Self::PlayerId(_prisma::read_filters::StringFilter::Equals(value))
                }
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::BigIntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(key_code_1::NAME),
                ::prisma_client_rust::sel(key_code_2::NAME),
                ::prisma_client_rust::sel(key_code_3::NAME),
                ::prisma_client_rust::sel(key_code_4::NAME),
                ::prisma_client_rust::sel(master_volume::NAME),
                ::prisma_client_rust::sel(music_volume::NAME),
                ::prisma_client_rust::sel(sound_effect_volume::NAME),
                ::prisma_client_rust::sel(offset::NAME),
                ::prisma_client_rust::sel(frame_rate::NAME),
                ::prisma_client_rust::sel(player_id::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            key_code_1: i32,
            key_code_2: i32,
            key_code_3: i32,
            key_code_4: i32,
            master_volume: i32,
            music_volume: i32,
            sound_effect_volume: i32,
            offset: i32,
            frame_rate: i32,
            player: super::player::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                key_code_1::set(key_code_1),
                key_code_2::set(key_code_2),
                key_code_3::set(key_code_3),
                key_code_4::set(key_code_4),
                master_volume::set(master_volume),
                music_volume::set(music_volume),
                sound_effect_volume::set(sound_effect_volume),
                offset::set(offset),
                frame_rate::set(frame_rate),
                player::connect(player),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            key_code_1: i32,
            key_code_2: i32,
            key_code_3: i32,
            key_code_4: i32,
            master_volume: i32,
            music_volume: i32,
            sound_effect_volume: i32,
            offset: i32,
            frame_rate: i32,
            player_id: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                key_code_1::set(key_code_1),
                key_code_2::set(key_code_2),
                key_code_3::set(key_code_3),
                key_code_4::set(key_code_4),
                master_volume::set(master_volume),
                music_volume::set(music_volume),
                sound_effect_volume::set(sound_effect_volume),
                offset::set(offset),
                frame_rate::set(frame_rate),
                player_id::set(player_id),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (
                key_code_1,
                key_code_2,
                key_code_3,
                key_code_4,
                master_volume,
                music_volume,
                sound_effect_volume,
                offset,
                frame_rate,
                player,
                mut _params,
            ): (
                i32,
                i32,
                i32,
                i32,
                i32,
                i32,
                i32,
                i32,
                i32,
                super::player::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                key_code_1::set(key_code_1),
                key_code_2::set(key_code_2),
                key_code_3::set(key_code_3),
                key_code_4::set(key_code_4),
                master_volume::set(master_volume),
                music_volume::set(music_volume),
                sound_effect_volume::set(sound_effect_volume),
                offset::set(offset),
                frame_rate::set(frame_rate),
                player::connect(player),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod _prisma {
    pub struct PrismaClientBuilder {
        url: Option<String>,
        action_notifier: ::prisma_client_rust::ActionNotifier,
    }
    impl PrismaClientBuilder {
        fn new() -> Self {
            Self {
                url: None,
                action_notifier: ::prisma_client_rust::ActionNotifier::new(),
            }
        }
        pub fn with_url(mut self, url: String) -> Self {
            self.url = Some(url);
            self
        }
        pub async fn build(self) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
            let internals = ::prisma_client_rust::PrismaClientInternals::new(
                self.url,
                self.action_notifier,
                super::DATAMODEL_STR,
            )
            .await?;
            Ok(PrismaClient(internals))
        }
    }
    pub struct PrismaClient(::prisma_client_rust::PrismaClientInternals);
    impl ::std::fmt::Debug for PrismaClient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.debug_struct("PrismaClient").finish()
        }
    }
    impl PrismaClient {
        pub fn _builder() -> PrismaClientBuilder {
            PrismaClientBuilder::new()
        }
        pub fn _query_raw<T: ::prisma_client_rust::Data>(
            &self,
            query: ::prisma_client_rust::Raw,
        ) -> ::prisma_client_rust::QueryRaw<T> {
            ::prisma_client_rust::QueryRaw::new(&self.0, query, super::DATABASE_STR)
        }
        pub fn _execute_raw(
            &self,
            query: ::prisma_client_rust::Raw,
        ) -> ::prisma_client_rust::ExecuteRaw {
            ::prisma_client_rust::ExecuteRaw::new(&self.0, query, super::DATABASE_STR)
        }
        pub async fn _batch<
            'batch,
            T: ::prisma_client_rust::BatchContainer<'batch, Marker>,
            Marker,
        >(
            &self,
            queries: T,
        ) -> ::prisma_client_rust::Result<
            <T as ::prisma_client_rust::BatchContainer<'batch, Marker>>::ReturnType,
        > {
            ::prisma_client_rust::batch(queries, &self.0).await
        }
        pub fn _transaction(&self) -> ::prisma_client_rust::TransactionBuilder<Self> {
            ::prisma_client_rust::TransactionBuilder::_new(self, &self.0)
        }
        pub fn player(&self) -> super::player::Actions {
            super::player::Actions { client: &self.0 }
        }
        pub fn achievement(&self) -> super::achievement::Actions {
            super::achievement::Actions { client: &self.0 }
        }
        pub fn score(&self) -> super::score::Actions {
            super::score::Actions { client: &self.0 }
        }
        pub fn setting(&self) -> super::setting::Actions {
            super::setting::Actions { client: &self.0 }
        }
    }
    impl ::prisma_client_rust::PrismaClient for PrismaClient {
        fn internals(&self) -> &::prisma_client_rust::PrismaClientInternals {
            &self.0
        }
        fn internals_mut(&mut self) -> &mut ::prisma_client_rust::PrismaClientInternals {
            &mut self.0
        }
        fn with_tx_id(&self, tx_id: Option<::prisma_client_rust::query_core::TxId>) -> Self {
            Self(self.0.with_tx_id(tx_id))
        }
    }
    #[derive(Debug, Clone, Copy, ::serde::Serialize, ::serde::Deserialize, PartialEq, Eq)]
    pub enum AchievementScalarFieldEnum {
        #[serde(rename = "Id")]
        Id,
        #[serde(rename = "Name")]
        Name,
        #[serde(rename = "Detail")]
        Detail,
        #[serde(rename = "FavorText")]
        FavorText,
    }
    impl ToString for AchievementScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "Id".to_string(),
                Self::Name => "Name".to_string(),
                Self::Detail => "Detail".to_string(),
                Self::FavorText => "FavorText".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, ::serde::Serialize, ::serde::Deserialize, PartialEq, Eq)]
    pub enum PlayerScalarFieldEnum {
        #[serde(rename = "Id")]
        Id,
        #[serde(rename = "NumericId")]
        NumericId,
        #[serde(rename = "Handle")]
        Handle,
        #[serde(rename = "Email")]
        Email,
        #[serde(rename = "HashedPassword")]
        HashedPassword,
        #[serde(rename = "HashedTemporaryPassword")]
        HashedTemporaryPassword,
        #[serde(rename = "TotalPlayTime")]
        TotalPlayTime,
        #[serde(rename = "Level")]
        Level,
        #[serde(rename = "ExpOfLevel")]
        ExpOfLevel,
        #[serde(rename = "CreationDate")]
        CreationDate,
    }
    impl ToString for PlayerScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "Id".to_string(),
                Self::NumericId => "NumericId".to_string(),
                Self::Handle => "Handle".to_string(),
                Self::Email => "Email".to_string(),
                Self::HashedPassword => "HashedPassword".to_string(),
                Self::HashedTemporaryPassword => "HashedTemporaryPassword".to_string(),
                Self::TotalPlayTime => "TotalPlayTime".to_string(),
                Self::Level => "Level".to_string(),
                Self::ExpOfLevel => "ExpOfLevel".to_string(),
                Self::CreationDate => "CreationDate".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, ::serde::Serialize, ::serde::Deserialize, PartialEq, Eq)]
    pub enum ScoreScalarFieldEnum {
        #[serde(rename = "Id")]
        Id,
        #[serde(rename = "TrackId")]
        TrackId,
        #[serde(rename = "TrackName")]
        TrackName,
        #[serde(rename = "TotalPoints")]
        TotalPoints,
        #[serde(rename = "Accuracy")]
        Accuracy,
        #[serde(rename = "Critical")]
        Critical,
        #[serde(rename = "MaxCombo")]
        MaxCombo,
        #[serde(rename = "Grade")]
        Grade,
        #[serde(rename = "Perfect")]
        Perfect,
        #[serde(rename = "Good")]
        Good,
        #[serde(rename = "Bad")]
        Bad,
        #[serde(rename = "Miss")]
        Miss,
        #[serde(rename = "RawJson")]
        RawJson,
        #[serde(rename = "SubmissionDate")]
        SubmissionDate,
        #[serde(rename = "PlayerId")]
        PlayerId,
    }
    impl ToString for ScoreScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "Id".to_string(),
                Self::TrackId => "TrackId".to_string(),
                Self::TrackName => "TrackName".to_string(),
                Self::TotalPoints => "TotalPoints".to_string(),
                Self::Accuracy => "Accuracy".to_string(),
                Self::Critical => "Critical".to_string(),
                Self::MaxCombo => "MaxCombo".to_string(),
                Self::Grade => "Grade".to_string(),
                Self::Perfect => "Perfect".to_string(),
                Self::Good => "Good".to_string(),
                Self::Bad => "Bad".to_string(),
                Self::Miss => "Miss".to_string(),
                Self::RawJson => "RawJson".to_string(),
                Self::SubmissionDate => "SubmissionDate".to_string(),
                Self::PlayerId => "PlayerId".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, ::serde::Serialize, ::serde::Deserialize, PartialEq, Eq)]
    pub enum SettingScalarFieldEnum {
        #[serde(rename = "Id")]
        Id,
        #[serde(rename = "KeyCode1")]
        KeyCode1,
        #[serde(rename = "KeyCode2")]
        KeyCode2,
        #[serde(rename = "KeyCode3")]
        KeyCode3,
        #[serde(rename = "KeyCode4")]
        KeyCode4,
        #[serde(rename = "MasterVolume")]
        MasterVolume,
        #[serde(rename = "MusicVolume")]
        MusicVolume,
        #[serde(rename = "SoundEffectVolume")]
        SoundEffectVolume,
        #[serde(rename = "Offset")]
        Offset,
        #[serde(rename = "FrameRate")]
        FrameRate,
        #[serde(rename = "PlayerId")]
        PlayerId,
    }
    impl ToString for SettingScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "Id".to_string(),
                Self::KeyCode1 => "KeyCode1".to_string(),
                Self::KeyCode2 => "KeyCode2".to_string(),
                Self::KeyCode3 => "KeyCode3".to_string(),
                Self::KeyCode4 => "KeyCode4".to_string(),
                Self::MasterVolume => "MasterVolume".to_string(),
                Self::MusicVolume => "MusicVolume".to_string(),
                Self::SoundEffectVolume => "SoundEffectVolume".to_string(),
                Self::Offset => "Offset".to_string(),
                Self::FrameRate => "FrameRate".to_string(),
                Self::PlayerId => "PlayerId".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, ::serde::Serialize, ::serde::Deserialize, PartialEq, Eq)]
    pub enum SortOrder {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }
    impl ToString for SortOrder {
        fn to_string(&self) -> String {
            match self {
                Self::Asc => "asc".to_string(),
                Self::Desc => "desc".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, ::serde::Serialize, ::serde::Deserialize, PartialEq, Eq)]
    pub enum TransactionIsolationLevel {
        #[serde(rename = "Serializable")]
        Serializable,
    }
    impl ToString for TransactionIsolationLevel {
        fn to_string(&self) -> String {
            match self {
                Self::Serializable => "Serializable".to_string(),
            }
        }
    }
    impl ::prisma_client_rust::TransactionIsolationLevel for TransactionIsolationLevel {}
    pub mod read_filters {
        #[derive(Clone)]
        pub enum StringFilter {
            Equals(String),
            InVec(Vec<String>),
            NotInVec(Vec<String>),
            Lt(String),
            Lte(String),
            Gt(String),
            Gte(String),
            Contains(String),
            StartsWith(String),
            EndsWith(String),
            Not(String),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for StringFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Contains(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "contains".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::StartsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "startsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::EndsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "endsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum BigIntFilter {
            Equals(i64),
            InVec(Vec<i64>),
            NotInVec(Vec<i64>),
            Lt(i64),
            Lte(i64),
            Gt(i64),
            Gte(i64),
            Not(i64),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for BigIntFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::BigInt(value),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum DateTimeFilter {
            Equals(
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            ),
            InVec(
                Vec<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
            NotInVec(
                Vec<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
            Lt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Lte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Gt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Gte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Not(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for DateTimeFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::DateTime(value),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum FloatFilter {
            Equals(f64),
            InVec(Vec<f64>),
            NotInVec(Vec<f64>),
            Lt(f64),
            Lte(f64),
            Gt(f64),
            Gte(f64),
            Not(f64),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for FloatFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![("equals".to_string(), ::prisma_client_rust::PrismaValue::Float(<::prisma_client_rust::bigdecimal::BigDecimal as ::prisma_client_rust::bigdecimal::FromPrimitive>::from_f64(value).unwrap().normalized()))]),
                    Self::InVec(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![("in".to_string(), ::prisma_client_rust::PrismaValue::List(value.into_iter().map(|value| ::prisma_client_rust::PrismaValue::Float(<::prisma_client_rust::bigdecimal::BigDecimal as ::prisma_client_rust::bigdecimal::FromPrimitive>::from_f64(value).unwrap().normalized())).collect()))]),
                    Self::NotInVec(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![("notIn".to_string(), ::prisma_client_rust::PrismaValue::List(value.into_iter().map(|value| ::prisma_client_rust::PrismaValue::Float(<::prisma_client_rust::bigdecimal::BigDecimal as ::prisma_client_rust::bigdecimal::FromPrimitive>::from_f64(value).unwrap().normalized())).collect()))]),
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![("lt".to_string(), ::prisma_client_rust::PrismaValue::Float(<::prisma_client_rust::bigdecimal::BigDecimal as ::prisma_client_rust::bigdecimal::FromPrimitive>::from_f64(value).unwrap().normalized()))]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![("lte".to_string(), ::prisma_client_rust::PrismaValue::Float(<::prisma_client_rust::bigdecimal::BigDecimal as ::prisma_client_rust::bigdecimal::FromPrimitive>::from_f64(value).unwrap().normalized()))]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![("gt".to_string(), ::prisma_client_rust::PrismaValue::Float(<::prisma_client_rust::bigdecimal::BigDecimal as ::prisma_client_rust::bigdecimal::FromPrimitive>::from_f64(value).unwrap().normalized()))]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![("gte".to_string(), ::prisma_client_rust::PrismaValue::Float(<::prisma_client_rust::bigdecimal::BigDecimal as ::prisma_client_rust::bigdecimal::FromPrimitive>::from_f64(value).unwrap().normalized()))]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![("not".to_string(), ::prisma_client_rust::PrismaValue::Float(<::prisma_client_rust::bigdecimal::BigDecimal as ::prisma_client_rust::bigdecimal::FromPrimitive>::from_f64(value).unwrap().normalized()))])
                }
            }
        }
        #[derive(Clone)]
        pub enum IntFilter {
            Equals(i32),
            InVec(Vec<i32>),
            NotInVec(Vec<i32>),
            Lt(i32),
            Lte(i32),
            Gt(i32),
            Gte(i32),
            Not(i32),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for IntFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Int(value as i64),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Int(value as i64)
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Int(value as i64)
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                }
            }
        }
    }
}
pub use _prisma::*;
